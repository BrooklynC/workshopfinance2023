<<<<<<< HEAD
{"version":3,"names":["buildWrapper","template","statement","buildAnonymousWrapper","injectWrapper","path","wrapper","body","directives","node","amdFactoryCall","pushContainer","get","amdFactoryCallArgs","amdFactory","length","declare","api","options","assertVersion","allowTopLevelThis","strict","strictMode","importInterop","noInterop","constantReexports","assumption","loose","enumerableModuleMeta","name","pre","file","set","visitor","CallExpression","state","has","isImport","requireId","resolveId","rejectId","scope","generateUidIdentifier","result","t","identifier","wrapInterop","replaceWith","buildDynamicImport","specifier","expression","ast","cloneNode","Program","exit","isModule","REQUIRE","amdArgs","importNames","push","stringLiteral","moduleName","getModuleName","opts","meta","headers","rewriteModuleStatementsAndPrepareHeader","filename","hasExports","exportName","source","metadata","isSideEffectImport","interop","header","expressionStatement","assignmentExpression","loc","buildNamespaceInitStatements","ensureStatementsHoisted","unshiftContainer","MODULE_NAME","AMD_ARGUMENTS","arrayExpression","IMPORT_NAMES"],"sources":["../src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport {\n  buildDynamicImport,\n  isModule,\n  rewriteModuleStatementsAndPrepareHeader,\n  type RewriteModuleStatementsAndPrepareHeaderOptions,\n  hasExports,\n  isSideEffectImport,\n  buildNamespaceInitStatements,\n  ensureStatementsHoisted,\n  wrapInterop,\n  getModuleName,\n} from \"@babel/helper-module-transforms\";\nimport { template, types as t } from \"@babel/core\";\nimport type { PluginOptions } from \"@babel/helper-module-transforms\";\nimport type { NodePath } from \"@babel/traverse\";\n\nconst buildWrapper = template.statement(`\n  define(MODULE_NAME, AMD_ARGUMENTS, function(IMPORT_NAMES) {\n  })\n`);\n\nconst buildAnonymousWrapper = template.statement(`\n  define([\"require\"], function(REQUIRE) {\n  })\n`);\n\nfunction injectWrapper(\n  path: NodePath<t.Program>,\n  wrapper: t.ExpressionStatement,\n) {\n  const { body, directives } = path.node;\n  path.node.directives = [];\n  path.node.body = [];\n  const amdFactoryCall = path\n    .pushContainer(\"body\", wrapper)[0]\n    .get(\"expression\") as NodePath<t.CallExpression>;\n  const amdFactoryCallArgs = amdFactoryCall.get(\"arguments\");\n  const amdFactory = (\n    amdFactoryCallArgs[\n      amdFactoryCallArgs.length - 1\n    ] as NodePath<t.FunctionExpression>\n  ).get(\"body\");\n  amdFactory.pushContainer(\"directives\", directives);\n  amdFactory.pushContainer(\"body\", body);\n}\n\nexport interface Options extends PluginOptions {\n  allowTopLevelThis?: boolean;\n  importInterop?: RewriteModuleStatementsAndPrepareHeaderOptions[\"importInterop\"];\n  loose?: boolean;\n  noInterop?: boolean;\n  strict?: boolean;\n  strictMode?: boolean;\n}\n\ntype State = {\n  requireId?: t.Identifier;\n  resolveId?: t.Identifier;\n  rejectId?: t.Identifier;\n};\n\nexport default declare<State>((api, options: Options) => {\n  api.assertVersion(7);\n\n  const { allowTopLevelThis, strict, strictMode, importInterop, noInterop } =\n    options;\n\n  const constantReexports =\n    api.assumption(\"constantReexports\") ?? options.loose;\n  const enumerableModuleMeta =\n    api.assumption(\"enumerableModuleMeta\") ?? options.loose;\n\n  return {\n    name: \"transform-modules-amd\",\n\n    pre() {\n      this.file.set(\"@babel/plugin-transform-modules-*\", \"amd\");\n    },\n\n    visitor: {\n      CallExpression(path, state) {\n        if (!this.file.has(\"@babel/plugin-proposal-dynamic-import\")) return;\n        if (!path.get(\"callee\").isImport()) return;\n\n        let { requireId, resolveId, rejectId } = state;\n        if (!requireId) {\n          requireId = path.scope.generateUidIdentifier(\"require\");\n          state.requireId = requireId;\n        }\n        if (!resolveId || !rejectId) {\n          resolveId = path.scope.generateUidIdentifier(\"resolve\");\n          rejectId = path.scope.generateUidIdentifier(\"reject\");\n          state.resolveId = resolveId;\n          state.rejectId = rejectId;\n        }\n\n        let result: t.Node = t.identifier(\"imported\");\n        if (!noInterop) result = wrapInterop(path, result, \"namespace\");\n\n        path.replaceWith(\n          buildDynamicImport(\n            path.node,\n            false,\n            false,\n            specifier => template.expression.ast`\n              new Promise((${resolveId}, ${rejectId}) =>\n                ${requireId}(\n                  [${specifier}],\n                  imported => ${t.cloneNode(resolveId)}(${result}),\n                  ${t.cloneNode(rejectId)}\n                )\n              )\n            `,\n          ),\n        );\n      },\n\n      Program: {\n        exit(path, { requireId }) {\n          if (!isModule(path)) {\n            if (requireId) {\n              injectWrapper(\n                path,\n                buildAnonymousWrapper({\n                  REQUIRE: t.cloneNode(requireId),\n                }) as t.ExpressionStatement,\n              );\n            }\n            return;\n          }\n\n          const amdArgs = [];\n          const importNames = [];\n          if (requireId) {\n            amdArgs.push(t.stringLiteral(\"require\"));\n            importNames.push(t.cloneNode(requireId));\n          }\n\n          let moduleName = getModuleName(this.file.opts, options);\n          // @ts-expect-error todo(flow->ts): do not reuse variables\n          if (moduleName) moduleName = t.stringLiteral(moduleName);\n\n          const { meta, headers } = rewriteModuleStatementsAndPrepareHeader(\n            path,\n            {\n              enumerableModuleMeta,\n              constantReexports,\n              strict,\n              strictMode,\n              allowTopLevelThis,\n              importInterop,\n              noInterop,\n              filename: this.file.opts.filename,\n            },\n          );\n\n          if (hasExports(meta)) {\n            amdArgs.push(t.stringLiteral(\"exports\"));\n\n            importNames.push(t.identifier(meta.exportName));\n          }\n\n          for (const [source, metadata] of meta.source) {\n            amdArgs.push(t.stringLiteral(source));\n            importNames.push(t.identifier(metadata.name));\n\n            if (!isSideEffectImport(metadata)) {\n              const interop = wrapInterop(\n                path,\n                t.identifier(metadata.name),\n                metadata.interop,\n              );\n              if (interop) {\n                const header = t.expressionStatement(\n                  t.assignmentExpression(\n                    \"=\",\n                    t.identifier(metadata.name),\n                    interop,\n                  ),\n                );\n                header.loc = metadata.loc;\n                headers.push(header);\n              }\n            }\n\n            headers.push(\n              ...buildNamespaceInitStatements(\n                meta,\n                metadata,\n                constantReexports,\n              ),\n            );\n          }\n\n          ensureStatementsHoisted(headers);\n          path.unshiftContainer(\"body\", headers);\n\n          injectWrapper(\n            path,\n            buildWrapper({\n              MODULE_NAME: moduleName,\n\n              AMD_ARGUMENTS: t.arrayExpression(amdArgs),\n              IMPORT_NAMES: importNames,\n            }) as t.ExpressionStatement,\n          );\n        },\n      },\n    },\n  };\n});\n"],"mappings":"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"}
=======
<<<<<<< HEAD
{"version":3,"names":["buildWrapper","template","statement","buildAnonymousWrapper","injectWrapper","path","wrapper","body","directives","node","amdFactoryCall","pushContainer","get","amdFactoryCallArgs","amdFactory","length","declare","api","options","assertVersion","allowTopLevelThis","strict","strictMode","importInterop","noInterop","constantReexports","assumption","loose","enumerableModuleMeta","name","pre","file","set","visitor","CallExpression","state","has","isImport","requireId","resolveId","rejectId","scope","generateUidIdentifier","result","t","identifier","wrapInterop","replaceWith","expression","ast","getDynamicImportSource","cloneNode","Program","exit","isModule","REQUIRE","amdArgs","importNames","push","stringLiteral","moduleName","getModuleName","opts","meta","headers","rewriteModuleStatementsAndPrepareHeader","filename","hasExports","exportName","source","metadata","isSideEffectImport","interop","header","expressionStatement","assignmentExpression","loc","buildNamespaceInitStatements","ensureStatementsHoisted","unshiftContainer","MODULE_NAME","AMD_ARGUMENTS","arrayExpression","IMPORT_NAMES"],"sources":["../src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport {\n  isModule,\n  rewriteModuleStatementsAndPrepareHeader,\n  type RewriteModuleStatementsAndPrepareHeaderOptions,\n  hasExports,\n  isSideEffectImport,\n  buildNamespaceInitStatements,\n  ensureStatementsHoisted,\n  wrapInterop,\n  getModuleName,\n  getDynamicImportSource,\n} from \"@babel/helper-module-transforms\";\nimport { template, types as t } from \"@babel/core\";\nimport type { PluginOptions } from \"@babel/helper-module-transforms\";\nimport type { NodePath } from \"@babel/traverse\";\n\nconst buildWrapper = template.statement(`\n  define(MODULE_NAME, AMD_ARGUMENTS, function(IMPORT_NAMES) {\n  })\n`);\n\nconst buildAnonymousWrapper = template.statement(`\n  define([\"require\"], function(REQUIRE) {\n  })\n`);\n\nfunction injectWrapper(\n  path: NodePath<t.Program>,\n  wrapper: t.ExpressionStatement,\n) {\n  const { body, directives } = path.node;\n  path.node.directives = [];\n  path.node.body = [];\n  const amdFactoryCall = path\n    .pushContainer(\"body\", wrapper)[0]\n    .get(\"expression\") as NodePath<t.CallExpression>;\n  const amdFactoryCallArgs = amdFactoryCall.get(\"arguments\");\n  const amdFactory = (\n    amdFactoryCallArgs[\n      amdFactoryCallArgs.length - 1\n    ] as NodePath<t.FunctionExpression>\n  ).get(\"body\") as NodePath<t.BlockStatement>;\n  amdFactory.pushContainer(\"directives\", directives);\n  amdFactory.pushContainer(\"body\", body);\n}\n\nexport interface Options extends PluginOptions {\n  allowTopLevelThis?: boolean;\n  importInterop?: RewriteModuleStatementsAndPrepareHeaderOptions[\"importInterop\"];\n  loose?: boolean;\n  noInterop?: boolean;\n  strict?: boolean;\n  strictMode?: boolean;\n}\n\ntype State = {\n  requireId?: t.Identifier;\n  resolveId?: t.Identifier;\n  rejectId?: t.Identifier;\n};\n\nexport default declare<State>((api, options: Options) => {\n  api.assertVersion(7);\n\n  const { allowTopLevelThis, strict, strictMode, importInterop, noInterop } =\n    options;\n\n  const constantReexports =\n    api.assumption(\"constantReexports\") ?? options.loose;\n  const enumerableModuleMeta =\n    api.assumption(\"enumerableModuleMeta\") ?? options.loose;\n\n  return {\n    name: \"transform-modules-amd\",\n\n    pre() {\n      this.file.set(\"@babel/plugin-transform-modules-*\", \"amd\");\n    },\n\n    visitor: {\n      CallExpression(path, state) {\n        if (!this.file.has(\"@babel/plugin-proposal-dynamic-import\")) return;\n        if (!path.get(\"callee\").isImport()) return;\n\n        let { requireId, resolveId, rejectId } = state;\n        if (!requireId) {\n          requireId = path.scope.generateUidIdentifier(\"require\");\n          state.requireId = requireId;\n        }\n        if (!resolveId || !rejectId) {\n          resolveId = path.scope.generateUidIdentifier(\"resolve\");\n          rejectId = path.scope.generateUidIdentifier(\"reject\");\n          state.resolveId = resolveId;\n          state.rejectId = rejectId;\n        }\n\n        let result: t.Node = t.identifier(\"imported\");\n        if (!noInterop) result = wrapInterop(path, result, \"namespace\");\n\n        path.replaceWith(\n          template.expression.ast`\n            new Promise((${resolveId}, ${rejectId}) =>\n              ${requireId}(\n                [${getDynamicImportSource(path.node)}],\n                imported => ${t.cloneNode(resolveId)}(${result}),\n                ${t.cloneNode(rejectId)}\n              )\n            )`,\n        );\n      },\n\n      Program: {\n        exit(path, { requireId }) {\n          if (!isModule(path)) {\n            if (requireId) {\n              injectWrapper(\n                path,\n                buildAnonymousWrapper({\n                  REQUIRE: t.cloneNode(requireId),\n                }) as t.ExpressionStatement,\n              );\n            }\n            return;\n          }\n\n          const amdArgs = [];\n          const importNames = [];\n          if (requireId) {\n            amdArgs.push(t.stringLiteral(\"require\"));\n            importNames.push(t.cloneNode(requireId));\n          }\n\n          let moduleName = getModuleName(this.file.opts, options);\n          // @ts-expect-error todo(flow->ts): do not reuse variables\n          if (moduleName) moduleName = t.stringLiteral(moduleName);\n\n          const { meta, headers } = rewriteModuleStatementsAndPrepareHeader(\n            path,\n            {\n              enumerableModuleMeta,\n              constantReexports,\n              strict,\n              strictMode,\n              allowTopLevelThis,\n              importInterop,\n              noInterop,\n              filename: this.file.opts.filename,\n            },\n          );\n\n          if (hasExports(meta)) {\n            amdArgs.push(t.stringLiteral(\"exports\"));\n\n            importNames.push(t.identifier(meta.exportName));\n          }\n\n          for (const [source, metadata] of meta.source) {\n            amdArgs.push(t.stringLiteral(source));\n            importNames.push(t.identifier(metadata.name));\n\n            if (!isSideEffectImport(metadata)) {\n              const interop = wrapInterop(\n                path,\n                t.identifier(metadata.name),\n                metadata.interop,\n              );\n              if (interop) {\n                const header = t.expressionStatement(\n                  t.assignmentExpression(\n                    \"=\",\n                    t.identifier(metadata.name),\n                    interop,\n                  ),\n                );\n                header.loc = metadata.loc;\n                headers.push(header);\n              }\n            }\n\n            headers.push(\n              ...buildNamespaceInitStatements(\n                meta,\n                metadata,\n                constantReexports,\n              ),\n            );\n          }\n\n          ensureStatementsHoisted(headers);\n          path.unshiftContainer(\"body\", headers);\n\n          injectWrapper(\n            path,\n            buildWrapper({\n              MODULE_NAME: moduleName,\n\n              AMD_ARGUMENTS: t.arrayExpression(amdArgs),\n              IMPORT_NAMES: importNames,\n            }) as t.ExpressionStatement,\n          );\n        },\n      },\n    },\n  };\n});\n"],"mappings":"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"}
=======
{"version":3,"names":["buildWrapper","template","statement","buildAnonymousWrapper","injectWrapper","path","wrapper","body","directives","node","amdFactoryCall","pushContainer","get","amdFactoryCallArgs","amdFactory","length","declare","api","options","assertVersion","allowTopLevelThis","strict","strictMode","importInterop","noInterop","constantReexports","assumption","loose","enumerableModuleMeta","name","pre","file","set","visitor","CallExpression","state","has","isImport","requireId","resolveId","rejectId","scope","generateUidIdentifier","result","t","identifier","wrapInterop","replaceWith","buildDynamicImport","specifier","expression","ast","cloneNode","Program","exit","isModule","REQUIRE","amdArgs","importNames","push","stringLiteral","moduleName","getModuleName","opts","meta","headers","rewriteModuleStatementsAndPrepareHeader","filename","hasExports","exportName","source","metadata","isSideEffectImport","interop","header","expressionStatement","assignmentExpression","loc","buildNamespaceInitStatements","ensureStatementsHoisted","unshiftContainer","MODULE_NAME","AMD_ARGUMENTS","arrayExpression","IMPORT_NAMES"],"sources":["../src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport {\n  buildDynamicImport,\n  isModule,\n  rewriteModuleStatementsAndPrepareHeader,\n  type RewriteModuleStatementsAndPrepareHeaderOptions,\n  hasExports,\n  isSideEffectImport,\n  buildNamespaceInitStatements,\n  ensureStatementsHoisted,\n  wrapInterop,\n  getModuleName,\n} from \"@babel/helper-module-transforms\";\nimport { template, types as t } from \"@babel/core\";\nimport type { PluginOptions } from \"@babel/helper-module-transforms\";\nimport type { NodePath } from \"@babel/traverse\";\n\nconst buildWrapper = template.statement(`\n  define(MODULE_NAME, AMD_ARGUMENTS, function(IMPORT_NAMES) {\n  })\n`);\n\nconst buildAnonymousWrapper = template.statement(`\n  define([\"require\"], function(REQUIRE) {\n  })\n`);\n\nfunction injectWrapper(\n  path: NodePath<t.Program>,\n  wrapper: t.ExpressionStatement,\n) {\n  const { body, directives } = path.node;\n  path.node.directives = [];\n  path.node.body = [];\n  const amdFactoryCall = path\n    .pushContainer(\"body\", wrapper)[0]\n    .get(\"expression\") as NodePath<t.CallExpression>;\n  const amdFactoryCallArgs = amdFactoryCall.get(\"arguments\");\n  const amdFactory = (\n    amdFactoryCallArgs[\n      amdFactoryCallArgs.length - 1\n    ] as NodePath<t.FunctionExpression>\n  ).get(\"body\");\n  amdFactory.pushContainer(\"directives\", directives);\n  amdFactory.pushContainer(\"body\", body);\n}\n\nexport interface Options extends PluginOptions {\n  allowTopLevelThis?: boolean;\n  importInterop?: RewriteModuleStatementsAndPrepareHeaderOptions[\"importInterop\"];\n  loose?: boolean;\n  noInterop?: boolean;\n  strict?: boolean;\n  strictMode?: boolean;\n}\n\ntype State = {\n  requireId?: t.Identifier;\n  resolveId?: t.Identifier;\n  rejectId?: t.Identifier;\n};\n\nexport default declare<State>((api, options: Options) => {\n  api.assertVersion(7);\n\n  const { allowTopLevelThis, strict, strictMode, importInterop, noInterop } =\n    options;\n\n  const constantReexports =\n    api.assumption(\"constantReexports\") ?? options.loose;\n  const enumerableModuleMeta =\n    api.assumption(\"enumerableModuleMeta\") ?? options.loose;\n\n  return {\n    name: \"transform-modules-amd\",\n\n    pre() {\n      this.file.set(\"@babel/plugin-transform-modules-*\", \"amd\");\n    },\n\n    visitor: {\n      CallExpression(path, state) {\n        if (!this.file.has(\"@babel/plugin-proposal-dynamic-import\")) return;\n        if (!path.get(\"callee\").isImport()) return;\n\n        let { requireId, resolveId, rejectId } = state;\n        if (!requireId) {\n          requireId = path.scope.generateUidIdentifier(\"require\");\n          state.requireId = requireId;\n        }\n        if (!resolveId || !rejectId) {\n          resolveId = path.scope.generateUidIdentifier(\"resolve\");\n          rejectId = path.scope.generateUidIdentifier(\"reject\");\n          state.resolveId = resolveId;\n          state.rejectId = rejectId;\n        }\n\n        let result: t.Node = t.identifier(\"imported\");\n        if (!noInterop) result = wrapInterop(path, result, \"namespace\");\n\n        path.replaceWith(\n          buildDynamicImport(\n            path.node,\n            false,\n            false,\n            specifier => template.expression.ast`\n              new Promise((${resolveId}, ${rejectId}) =>\n                ${requireId}(\n                  [${specifier}],\n                  imported => ${t.cloneNode(resolveId)}(${result}),\n                  ${t.cloneNode(rejectId)}\n                )\n              )\n            `,\n          ),\n        );\n      },\n\n      Program: {\n        exit(path, { requireId }) {\n          if (!isModule(path)) {\n            if (requireId) {\n              injectWrapper(\n                path,\n                buildAnonymousWrapper({\n                  REQUIRE: t.cloneNode(requireId),\n                }) as t.ExpressionStatement,\n              );\n            }\n            return;\n          }\n\n          const amdArgs = [];\n          const importNames = [];\n          if (requireId) {\n            amdArgs.push(t.stringLiteral(\"require\"));\n            importNames.push(t.cloneNode(requireId));\n          }\n\n          let moduleName = getModuleName(this.file.opts, options);\n          // @ts-expect-error todo(flow->ts): do not reuse variables\n          if (moduleName) moduleName = t.stringLiteral(moduleName);\n\n          const { meta, headers } = rewriteModuleStatementsAndPrepareHeader(\n            path,\n            {\n              enumerableModuleMeta,\n              constantReexports,\n              strict,\n              strictMode,\n              allowTopLevelThis,\n              importInterop,\n              noInterop,\n              filename: this.file.opts.filename,\n            },\n          );\n\n          if (hasExports(meta)) {\n            amdArgs.push(t.stringLiteral(\"exports\"));\n\n            importNames.push(t.identifier(meta.exportName));\n          }\n\n          for (const [source, metadata] of meta.source) {\n            amdArgs.push(t.stringLiteral(source));\n            importNames.push(t.identifier(metadata.name));\n\n            if (!isSideEffectImport(metadata)) {\n              const interop = wrapInterop(\n                path,\n                t.identifier(metadata.name),\n                metadata.interop,\n              );\n              if (interop) {\n                const header = t.expressionStatement(\n                  t.assignmentExpression(\n                    \"=\",\n                    t.identifier(metadata.name),\n                    interop,\n                  ),\n                );\n                header.loc = metadata.loc;\n                headers.push(header);\n              }\n            }\n\n            headers.push(\n              ...buildNamespaceInitStatements(\n                meta,\n                metadata,\n                constantReexports,\n              ),\n            );\n          }\n\n          ensureStatementsHoisted(headers);\n          path.unshiftContainer(\"body\", headers);\n\n          injectWrapper(\n            path,\n            buildWrapper({\n              MODULE_NAME: moduleName,\n\n              AMD_ARGUMENTS: t.arrayExpression(amdArgs),\n              IMPORT_NAMES: importNames,\n            }) as t.ExpressionStatement,\n          );\n        },\n      },\n    },\n  };\n});\n"],"mappings":"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"}
>>>>>>> zen
>>>>>>> ede5c2d510e1c4029dfffa203387bb3f20d74fc6
