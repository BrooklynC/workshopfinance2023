<<<<<<< HEAD
{"version":3,"names":["assignmentExpression","booleanLiteral","callExpression","cloneNode","identifier","memberExpression","sequenceExpression","stringLiteral","thisExpression","getPrototypeOfExpression","objectRef","isStatic","file","isPrivateMethod","targetRef","addHelper","visitor","traverse","visitors","merge","environmentVisitor","Super","path","state","node","parentPath","isMemberExpression","object","handle","unshadowSuperBindingVisitor","Scopable","refName","binding","scope","getOwnBinding","name","rename","specHandlers","memoise","superMember","count","computed","property","memo","maybeGenerateMemoised","memoiser","set","prop","has","get","_get","_getThisRefs","thisRefs","proto","getObjectRef","this","isDerivedConstructor","thisRef","generateDeclaredUidIdentifier","value","isInStrictMode","destructureSet","buildCodeFrameError","call","args","optimiseCall","optionalCall","delete","template","expression","ast","looseHandlers","getSuperRef","ReplaceSupers","constructor","opts","methodPath","isClassMethod","kind","superRef","isObjectMethod","static","isStaticBlock","isPrivate","isMethod","constantSuper","isLoose","replace","refToPreserve","handler","memberExpressionToFunctions","bind","boundGet"],"sources":["../src/index.ts"],"sourcesContent":["import type { File } from \"@babel/core\";\nimport environmentVisitor from \"@babel/helper-environment-visitor\";\nimport memberExpressionToFunctions from \"@babel/helper-member-expression-to-functions\";\nimport type { HandlerState } from \"@babel/helper-member-expression-to-functions\";\nimport optimiseCall from \"@babel/helper-optimise-call-expression\";\nimport template from \"@babel/template\";\nimport traverse from \"@babel/traverse\";\nimport type { NodePath, Scope } from \"@babel/traverse\";\nimport {\n  assignmentExpression,\n  booleanLiteral,\n  callExpression,\n  cloneNode,\n  identifier,\n  memberExpression,\n  sequenceExpression,\n  stringLiteral,\n  thisExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\n// TODO (Babel 8): Don't export this.\nexport {\n  default as environmentVisitor,\n  skipAllButComputedKey,\n} from \"@babel/helper-environment-visitor\";\n\ntype ThisRef =\n  | {\n      memo: t.AssignmentExpression;\n      this: t.Identifier;\n    }\n  | { this: t.ThisExpression };\n/**\n * Creates an expression which result is the proto of objectRef.\n *\n * @example <caption>isStatic === true</caption>\n *\n *   helpers.getPrototypeOf(CLASS)\n *\n * @example <caption>isStatic === false</caption>\n *\n *   helpers.getPrototypeOf(CLASS.prototype)\n */\nfunction getPrototypeOfExpression(\n  objectRef: t.Identifier,\n  isStatic: boolean,\n  file: File,\n  isPrivateMethod: boolean,\n) {\n  objectRef = cloneNode(objectRef);\n  const targetRef =\n    isStatic || isPrivateMethod\n      ? objectRef\n      : memberExpression(objectRef, identifier(\"prototype\"));\n\n  return callExpression(file.addHelper(\"getPrototypeOf\"), [targetRef]);\n}\n\nconst visitor = traverse.visitors.merge<\n  HandlerState<ReplaceState> & ReplaceState\n>([\n  environmentVisitor,\n  {\n    Super(path, state) {\n      const { node, parentPath } = path;\n      if (!parentPath.isMemberExpression({ object: node })) return;\n      state.handle(parentPath);\n    },\n  },\n]);\n\nconst unshadowSuperBindingVisitor = traverse.visitors.merge<{\n  refName: string;\n}>([\n  environmentVisitor,\n  {\n    Scopable(path, { refName }) {\n      // https://github.com/Zzzen/babel/pull/1#pullrequestreview-564833183\n      const binding = path.scope.getOwnBinding(refName);\n      if (binding && binding.identifier.name === refName) {\n        path.scope.rename(refName);\n      }\n    },\n  },\n]);\n\ntype SharedState = {\n  file: File;\n  scope: Scope;\n  isDerivedConstructor: boolean;\n  isStatic: boolean;\n  isPrivateMethod: boolean;\n  getObjectRef: () => t.Identifier;\n  getSuperRef: () => t.Identifier;\n  // we dont need boundGet here, but memberExpressionToFunctions handler needs it.\n  boundGet: HandlerState[\"get\"];\n};\n\ntype Handler = HandlerState<SharedState> & SharedState;\ntype SuperMember = NodePath<\n  | t.MemberExpression & {\n      object: t.Super;\n      property: Exclude<t.MemberExpression[\"property\"], t.PrivateName>;\n    }\n>;\n\ninterface SpecHandler\n  extends Pick<\n    Handler,\n    | \"memoise\"\n    | \"get\"\n    | \"set\"\n    | \"destructureSet\"\n    | \"call\"\n    | \"optionalCall\"\n    | \"delete\"\n  > {\n  _get(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    thisRefs: ThisRef,\n  ): t.CallExpression;\n  _getThisRefs(): ThisRef;\n  prop(this: Handler & SpecHandler, superMember: SuperMember): t.Expression;\n}\n\nconst specHandlers: SpecHandler = {\n  memoise(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    count: number,\n  ) {\n    const { scope, node } = superMember;\n    const { computed, property } = node;\n    if (!computed) {\n      return;\n    }\n\n    const memo = scope.maybeGenerateMemoised(property);\n    if (!memo) {\n      return;\n    }\n\n    this.memoiser.set(property, memo, count);\n  },\n\n  prop(this: Handler & SpecHandler, superMember: SuperMember) {\n    const { computed, property } = superMember.node;\n    if (this.memoiser.has(property)) {\n      return cloneNode(this.memoiser.get(property));\n    }\n\n    if (computed) {\n      return cloneNode(property);\n    }\n\n    return stringLiteral((property as t.Identifier).name);\n  },\n\n  get(this: Handler & SpecHandler, superMember: SuperMember) {\n    return this._get(superMember, this._getThisRefs());\n  },\n\n  _get(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    thisRefs: ThisRef,\n  ) {\n    const proto = getPrototypeOfExpression(\n      this.getObjectRef(),\n      this.isStatic,\n      this.file,\n      this.isPrivateMethod,\n    );\n    return callExpression(this.file.addHelper(\"get\"), [\n      // @ts-expect-error memo does not exist when this.isDerivedConstructor is false\n      thisRefs.memo ? sequenceExpression([thisRefs.memo, proto]) : proto,\n      this.prop(superMember),\n      thisRefs.this,\n    ]);\n  },\n\n  _getThisRefs(this: Handler & SpecHandler): ThisRef {\n    if (!this.isDerivedConstructor) {\n      return { this: thisExpression() };\n    }\n    const thisRef = this.scope.generateDeclaredUidIdentifier(\"thisSuper\");\n    return {\n      memo: assignmentExpression(\"=\", thisRef, thisExpression()),\n      this: cloneNode(thisRef),\n    };\n  },\n\n  set(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    value: t.Expression,\n  ) {\n    const thisRefs = this._getThisRefs();\n    const proto = getPrototypeOfExpression(\n      this.getObjectRef(),\n      this.isStatic,\n      this.file,\n      this.isPrivateMethod,\n    );\n    return callExpression(this.file.addHelper(\"set\"), [\n      // @ts-expect-error memo does not exist when this.isDerivedConstructor is false\n      thisRefs.memo ? sequenceExpression([thisRefs.memo, proto]) : proto,\n      this.prop(superMember),\n      value,\n      thisRefs.this,\n      booleanLiteral(superMember.isInStrictMode()),\n    ]);\n  },\n\n  destructureSet(this: Handler & SpecHandler, superMember: SuperMember) {\n    throw superMember.buildCodeFrameError(\n      `Destructuring to a super field is not supported yet.`,\n    );\n  },\n\n  call(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    args: t.CallExpression[\"arguments\"],\n  ) {\n    const thisRefs = this._getThisRefs();\n    return optimiseCall(\n      this._get(superMember, thisRefs),\n      cloneNode(thisRefs.this),\n      args,\n      false,\n    );\n  },\n\n  optionalCall(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    args: t.CallExpression[\"arguments\"],\n  ) {\n    const thisRefs = this._getThisRefs();\n    return optimiseCall(\n      this._get(superMember, thisRefs),\n      cloneNode(thisRefs.this),\n      args,\n      true,\n    );\n  },\n\n  delete(this: Handler & SpecHandler, superMember: SuperMember) {\n    if (superMember.node.computed) {\n      return sequenceExpression([\n        callExpression(this.file.addHelper(\"toPropertyKey\"), [\n          cloneNode(superMember.node.property),\n        ]),\n        template.expression.ast`\n          function () { throw new ReferenceError(\"'delete super[expr]' is invalid\"); }()\n        `,\n      ]);\n    } else {\n      return template.expression.ast`\n        function () { throw new ReferenceError(\"'delete super.prop' is invalid\"); }()\n      `;\n    }\n  },\n};\n\nconst looseHandlers = {\n  ...specHandlers,\n\n  prop(this: Handler & typeof specHandlers, superMember: SuperMember) {\n    const { property } = superMember.node;\n    if (this.memoiser.has(property)) {\n      return cloneNode(this.memoiser.get(property));\n    }\n\n    return cloneNode(property);\n  },\n\n  get(this: Handler & typeof specHandlers, superMember: SuperMember) {\n    const { isStatic, getSuperRef } = this;\n    const { computed } = superMember.node;\n    const prop = this.prop(superMember);\n\n    let object;\n    if (isStatic) {\n      object =\n        getSuperRef() ??\n        memberExpression(identifier(\"Function\"), identifier(\"prototype\"));\n    } else {\n      object = memberExpression(\n        getSuperRef() ?? identifier(\"Object\"),\n        identifier(\"prototype\"),\n      );\n    }\n\n    return memberExpression(object, prop, computed);\n  },\n\n  set(\n    this: Handler & typeof specHandlers,\n    superMember: SuperMember,\n    value: t.Expression,\n  ) {\n    const { computed } = superMember.node;\n    const prop = this.prop(superMember);\n\n    return assignmentExpression(\n      \"=\",\n      memberExpression(thisExpression(), prop, computed),\n      value,\n    );\n  },\n\n  destructureSet(\n    this: Handler & typeof specHandlers,\n    superMember: SuperMember,\n  ) {\n    const { computed } = superMember.node;\n    const prop = this.prop(superMember);\n\n    return memberExpression(thisExpression(), prop, computed);\n  },\n\n  call(\n    this: Handler & typeof specHandlers,\n    superMember: SuperMember,\n    args: t.CallExpression[\"arguments\"],\n  ) {\n    return optimiseCall(this.get(superMember), thisExpression(), args, false);\n  },\n\n  optionalCall(\n    this: Handler & typeof specHandlers,\n    superMember: SuperMember,\n    args: t.CallExpression[\"arguments\"],\n  ) {\n    return optimiseCall(this.get(superMember), thisExpression(), args, true);\n  },\n};\n\ntype ReplaceSupersOptionsBase = {\n  methodPath: NodePath<\n    | t.ClassMethod\n    | t.ClassProperty\n    | t.ObjectMethod\n    | t.ClassPrivateMethod\n    | t.ClassPrivateProperty\n    | t.StaticBlock\n  >;\n  constantSuper?: boolean;\n  file: File;\n  // objectRef might have been shadowed in child scopes,\n  // in that case, we need to rename related variables.\n  refToPreserve?: t.Identifier;\n};\n\ntype ReplaceSupersOptions = ReplaceSupersOptionsBase &\n  (\n    | { objectRef?: undefined; getObjectRef: () => t.Node }\n    | { objectRef: t.Node; getObjectRef?: undefined }\n  ) &\n  (\n    | { superRef?: undefined; getSuperRef: () => t.Node }\n    | { superRef: t.Node; getSuperRef?: undefined }\n  );\n\ninterface ReplaceState {\n  file: File;\n  scope: Scope;\n  isDerivedConstructor: boolean;\n  isStatic: boolean;\n  isPrivateMethod: boolean;\n  getObjectRef: ReplaceSupers[\"getObjectRef\"];\n  getSuperRef: ReplaceSupers[\"getSuperRef\"];\n}\n\nexport default class ReplaceSupers {\n  constructor(opts: ReplaceSupersOptions) {\n    const path = opts.methodPath;\n\n    this.methodPath = path;\n    this.isDerivedConstructor =\n      path.isClassMethod({ kind: \"constructor\" }) && !!opts.superRef;\n    this.isStatic =\n      path.isObjectMethod() ||\n      // @ts-expect-error static is not in ClassPrivateMethod\n      path.node.static ||\n      path.isStaticBlock?.();\n    this.isPrivateMethod = path.isPrivate() && path.isMethod();\n\n    this.file = opts.file;\n    this.constantSuper = process.env.BABEL_8_BREAKING\n      ? opts.constantSuper\n      : // Fallback to isLoose for backward compatibility\n        opts.constantSuper ?? (opts as any).isLoose;\n    this.opts = opts;\n  }\n\n  declare file: File;\n  declare isDerivedConstructor: boolean;\n  declare constantSuper: boolean;\n  declare isPrivateMethod: boolean;\n  declare isStatic: boolean;\n  declare methodPath: NodePath;\n  declare opts: ReplaceSupersOptions;\n\n  getObjectRef() {\n    return cloneNode(this.opts.objectRef || this.opts.getObjectRef());\n  }\n\n  getSuperRef() {\n    if (this.opts.superRef) return cloneNode(this.opts.superRef);\n    if (this.opts.getSuperRef) {\n      return cloneNode(this.opts.getSuperRef());\n    }\n  }\n\n  replace() {\n    // https://github.com/babel/babel/issues/11994\n    if (this.opts.refToPreserve) {\n      this.methodPath.traverse(unshadowSuperBindingVisitor, {\n        refName: this.opts.refToPreserve.name,\n      });\n    }\n\n    const handler = this.constantSuper ? looseHandlers : specHandlers;\n\n    memberExpressionToFunctions<ReplaceState>(this.methodPath, visitor, {\n      file: this.file,\n      scope: this.methodPath.scope,\n      isDerivedConstructor: this.isDerivedConstructor,\n      isStatic: this.isStatic,\n      isPrivateMethod: this.isPrivateMethod,\n      getObjectRef: this.getObjectRef.bind(this),\n      getSuperRef: this.getSuperRef.bind(this),\n      // we dont need boundGet here, but memberExpressionToFunctions handler needs it.\n      boundGet: handler.get,\n      ...handler,\n    });\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AACA;AACA;AAEA;AACA;AACA;AAEA;AAUsB;EATpBA,oBAAoB;EACpBC,cAAc;EACdC,cAAc;EACdC,SAAS;EACTC,UAAU;EACVC,gBAAgB;EAChBC,kBAAkB;EAClBC,aAAa;EACbC;AAAc;AA2BhB,SAASC,wBAAwB,CAC/BC,SAAuB,EACvBC,QAAiB,EACjBC,IAAU,EACVC,eAAwB,EACxB;EACAH,SAAS,GAAGP,SAAS,CAACO,SAAS,CAAC;EAChC,MAAMI,SAAS,GACbH,QAAQ,IAAIE,eAAe,GACvBH,SAAS,GACTL,gBAAgB,CAACK,SAAS,EAAEN,UAAU,CAAC,WAAW,CAAC,CAAC;EAE1D,OAAOF,cAAc,CAACU,IAAI,CAACG,SAAS,CAAC,gBAAgB,CAAC,EAAE,CAACD,SAAS,CAAC,CAAC;AACtE;AAEA,MAAME,OAAO,GAAGC,iBAAQ,CAACC,QAAQ,CAACC,KAAK,CAErC,CACAC,iCAAkB,EAClB;EACEC,KAAK,CAACC,IAAI,EAAEC,KAAK,EAAE;IACjB,MAAM;MAAEC,IAAI;MAAEC;IAAW,CAAC,GAAGH,IAAI;IACjC,IAAI,CAACG,UAAU,CAACC,kBAAkB,CAAC;MAAEC,MAAM,EAAEH;IAAK,CAAC,CAAC,EAAE;IACtDD,KAAK,CAACK,MAAM,CAACH,UAAU,CAAC;EAC1B;AACF,CAAC,CACF,CAAC;AAEF,MAAMI,2BAA2B,GAAGZ,iBAAQ,CAACC,QAAQ,CAACC,KAAK,CAExD,CACDC,iCAAkB,EAClB;EACEU,QAAQ,CAACR,IAAI,EAAE;IAAES;EAAQ,CAAC,EAAE;IAE1B,MAAMC,OAAO,GAAGV,IAAI,CAACW,KAAK,CAACC,aAAa,CAACH,OAAO,CAAC;IACjD,IAAIC,OAAO,IAAIA,OAAO,CAAC5B,UAAU,CAAC+B,IAAI,KAAKJ,OAAO,EAAE;MAClDT,IAAI,CAACW,KAAK,CAACG,MAAM,CAACL,OAAO,CAAC;IAC5B;EACF;AACF,CAAC,CACF,CAAC;AA0CF,MAAMM,YAAyB,GAAG;EAChCC,OAAO,CAELC,WAAwB,EACxBC,KAAa,EACb;IACA,MAAM;MAAEP,KAAK;MAAET;IAAK,CAAC,GAAGe,WAAW;IACnC,MAAM;MAAEE,QAAQ;MAAEC;IAAS,CAAC,GAAGlB,IAAI;IACnC,IAAI,CAACiB,QAAQ,EAAE;MACb;IACF;IAEA,MAAME,IAAI,GAAGV,KAAK,CAACW,qBAAqB,CAACF,QAAQ,CAAC;IAClD,IAAI,CAACC,IAAI,EAAE;MACT;IACF;IAEA,IAAI,CAACE,QAAQ,CAACC,GAAG,CAACJ,QAAQ,EAAEC,IAAI,EAAEH,KAAK,CAAC;EAC1C,CAAC;EAEDO,IAAI,CAA8BR,WAAwB,EAAE;IAC1D,MAAM;MAAEE,QAAQ;MAAEC;IAAS,CAAC,GAAGH,WAAW,CAACf,IAAI;IAC/C,IAAI,IAAI,CAACqB,QAAQ,CAACG,GAAG,CAACN,QAAQ,CAAC,EAAE;MAC/B,OAAOvC,SAAS,CAAC,IAAI,CAAC0C,QAAQ,CAACI,GAAG,CAACP,QAAQ,CAAC,CAAC;IAC/C;IAEA,IAAID,QAAQ,EAAE;MACZ,OAAOtC,SAAS,CAACuC,QAAQ,CAAC;IAC5B;IAEA,OAAOnC,aAAa,CAAEmC,QAAQ,CAAkBP,IAAI,CAAC;EACvD,CAAC;EAEDc,GAAG,CAA8BV,WAAwB,EAAE;IACzD,OAAO,IAAI,CAACW,IAAI,CAACX,WAAW,EAAE,IAAI,CAACY,YAAY,EAAE,CAAC;EACpD,CAAC;EAEDD,IAAI,CAEFX,WAAwB,EACxBa,QAAiB,EACjB;IACA,MAAMC,KAAK,GAAG5C,wBAAwB,CACpC,IAAI,CAAC6C,YAAY,EAAE,EACnB,IAAI,CAAC3C,QAAQ,EACb,IAAI,CAACC,IAAI,EACT,IAAI,CAACC,eAAe,CACrB;IACD,OAAOX,cAAc,CAAC,IAAI,CAACU,IAAI,CAACG,SAAS,CAAC,KAAK,CAAC,EAAE;IAEhDqC,QAAQ,CAACT,IAAI,GAAGrC,kBAAkB,CAAC,CAAC8C,QAAQ,CAACT,IAAI,EAAEU,KAAK,CAAC,CAAC,GAAGA,KAAK,EAClE,IAAI,CAACN,IAAI,CAACR,WAAW,CAAC,EACtBa,QAAQ,CAACG,IAAI,CACd,CAAC;EACJ,CAAC;EAEDJ,YAAY,GAAuC;IACjD,IAAI,CAAC,IAAI,CAACK,oBAAoB,EAAE;MAC9B,OAAO;QAAED,IAAI,EAAE/C,cAAc;MAAG,CAAC;IACnC;IACA,MAAMiD,OAAO,GAAG,IAAI,CAACxB,KAAK,CAACyB,6BAA6B,CAAC,WAAW,CAAC;IACrE,OAAO;MACLf,IAAI,EAAE3C,oBAAoB,CAAC,GAAG,EAAEyD,OAAO,EAAEjD,cAAc,EAAE,CAAC;MAC1D+C,IAAI,EAAEpD,SAAS,CAACsD,OAAO;IACzB,CAAC;EACH,CAAC;EAEDX,GAAG,CAEDP,WAAwB,EACxBoB,KAAmB,EACnB;IACA,MAAMP,QAAQ,GAAG,IAAI,CAACD,YAAY,EAAE;IACpC,MAAME,KAAK,GAAG5C,wBAAwB,CACpC,IAAI,CAAC6C,YAAY,EAAE,EACnB,IAAI,CAAC3C,QAAQ,EACb,IAAI,CAACC,IAAI,EACT,IAAI,CAACC,eAAe,CACrB;IACD,OAAOX,cAAc,CAAC,IAAI,CAACU,IAAI,CAACG,SAAS,CAAC,KAAK,CAAC,EAAE;IAEhDqC,QAAQ,CAACT,IAAI,GAAGrC,kBAAkB,CAAC,CAAC8C,QAAQ,CAACT,IAAI,EAAEU,KAAK,CAAC,CAAC,GAAGA,KAAK,EAClE,IAAI,CAACN,IAAI,CAACR,WAAW,CAAC,EACtBoB,KAAK,EACLP,QAAQ,CAACG,IAAI,EACbtD,cAAc,CAACsC,WAAW,CAACqB,cAAc,EAAE,CAAC,CAC7C,CAAC;EACJ,CAAC;EAEDC,cAAc,CAA8BtB,WAAwB,EAAE;IACpE,MAAMA,WAAW,CAACuB,mBAAmB,CAClC,sDAAqD,CACvD;EACH,CAAC;EAEDC,IAAI,CAEFxB,WAAwB,EACxByB,IAAmC,EACnC;IACA,MAAMZ,QAAQ,GAAG,IAAI,CAACD,YAAY,EAAE;IACpC,OAAO,IAAAc,qCAAY,EACjB,IAAI,CAACf,IAAI,CAACX,WAAW,EAAEa,QAAQ,CAAC,EAChCjD,SAAS,CAACiD,QAAQ,CAACG,IAAI,CAAC,EACxBS,IAAI,EACJ,KAAK,CACN;EACH,CAAC;EAEDE,YAAY,CAEV3B,WAAwB,EACxByB,IAAmC,EACnC;IACA,MAAMZ,QAAQ,GAAG,IAAI,CAACD,YAAY,EAAE;IACpC,OAAO,IAAAc,qCAAY,EACjB,IAAI,CAACf,IAAI,CAACX,WAAW,EAAEa,QAAQ,CAAC,EAChCjD,SAAS,CAACiD,QAAQ,CAACG,IAAI,CAAC,EACxBS,IAAI,EACJ,IAAI,CACL;EACH,CAAC;EAEDG,MAAM,CAA8B5B,WAAwB,EAAE;IAC5D,IAAIA,WAAW,CAACf,IAAI,CAACiB,QAAQ,EAAE;MAC7B,OAAOnC,kBAAkB,CAAC,CACxBJ,cAAc,CAAC,IAAI,CAACU,IAAI,CAACG,SAAS,CAAC,eAAe,CAAC,EAAE,CACnDZ,SAAS,CAACoC,WAAW,CAACf,IAAI,CAACkB,QAAQ,CAAC,CACrC,CAAC,EACF0B,iBAAQ,CAACC,UAAU,CAACC,GAAI;AAChC;AACA,SAAS,CACF,CAAC;IACJ,CAAC,MAAM;MACL,OAAOF,iBAAQ,CAACC,UAAU,CAACC,GAAI;AACrC;AACA,OAAO;IACH;EACF;AACF,CAAC;AAED,MAAMC,aAAa,qBACdlC,YAAY;EAEfU,IAAI,CAAsCR,WAAwB,EAAE;IAClE,MAAM;MAAEG;IAAS,CAAC,GAAGH,WAAW,CAACf,IAAI;IACrC,IAAI,IAAI,CAACqB,QAAQ,CAACG,GAAG,CAACN,QAAQ,CAAC,EAAE;MAC/B,OAAOvC,SAAS,CAAC,IAAI,CAAC0C,QAAQ,CAACI,GAAG,CAACP,QAAQ,CAAC,CAAC;IAC/C;IAEA,OAAOvC,SAAS,CAACuC,QAAQ,CAAC;EAC5B,CAAC;EAEDO,GAAG,CAAsCV,WAAwB,EAAE;IACjE,MAAM;MAAE5B,QAAQ;MAAE6D;IAAY,CAAC,GAAG,IAAI;IACtC,MAAM;MAAE/B;IAAS,CAAC,GAAGF,WAAW,CAACf,IAAI;IACrC,MAAMuB,IAAI,GAAG,IAAI,CAACA,IAAI,CAACR,WAAW,CAAC;IAEnC,IAAIZ,MAAM;IACV,IAAIhB,QAAQ,EAAE;MAAA;MACZgB,MAAM,mBACJ6C,WAAW,EAAE,2BACbnE,gBAAgB,CAACD,UAAU,CAAC,UAAU,CAAC,EAAEA,UAAU,CAAC,WAAW,CAAC,CAAC;IACrE,CAAC,MAAM;MAAA;MACLuB,MAAM,GAAGtB,gBAAgB,kBACvBmE,WAAW,EAAE,4BAAIpE,UAAU,CAAC,QAAQ,CAAC,EACrCA,UAAU,CAAC,WAAW,CAAC,CACxB;IACH;IAEA,OAAOC,gBAAgB,CAACsB,MAAM,EAAEoB,IAAI,EAAEN,QAAQ,CAAC;EACjD,CAAC;EAEDK,GAAG,CAEDP,WAAwB,EACxBoB,KAAmB,EACnB;IACA,MAAM;MAAElB;IAAS,CAAC,GAAGF,WAAW,CAACf,IAAI;IACrC,MAAMuB,IAAI,GAAG,IAAI,CAACA,IAAI,CAACR,WAAW,CAAC;IAEnC,OAAOvC,oBAAoB,CACzB,GAAG,EACHK,gBAAgB,CAACG,cAAc,EAAE,EAAEuC,IAAI,EAAEN,QAAQ,CAAC,EAClDkB,KAAK,CACN;EACH,CAAC;EAEDE,cAAc,CAEZtB,WAAwB,EACxB;IACA,MAAM;MAAEE;IAAS,CAAC,GAAGF,WAAW,CAACf,IAAI;IACrC,MAAMuB,IAAI,GAAG,IAAI,CAACA,IAAI,CAACR,WAAW,CAAC;IAEnC,OAAOlC,gBAAgB,CAACG,cAAc,EAAE,EAAEuC,IAAI,EAAEN,QAAQ,CAAC;EAC3D,CAAC;EAEDsB,IAAI,CAEFxB,WAAwB,EACxByB,IAAmC,EACnC;IACA,OAAO,IAAAC,qCAAY,EAAC,IAAI,CAAChB,GAAG,CAACV,WAAW,CAAC,EAAE/B,cAAc,EAAE,EAAEwD,IAAI,EAAE,KAAK,CAAC;EAC3E,CAAC;EAEDE,YAAY,CAEV3B,WAAwB,EACxByB,IAAmC,EACnC;IACA,OAAO,IAAAC,qCAAY,EAAC,IAAI,CAAChB,GAAG,CAACV,WAAW,CAAC,EAAE/B,cAAc,EAAE,EAAEwD,IAAI,EAAE,IAAI,CAAC;EAC1E;AAAC,EACF;AAsCc,MAAMS,aAAa,CAAC;EACjCC,WAAW,CAACC,IAA0B,EAAE;IAAA;IACtC,MAAMrD,IAAI,GAAGqD,IAAI,CAACC,UAAU;IAE5B,IAAI,CAACA,UAAU,GAAGtD,IAAI;IACtB,IAAI,CAACkC,oBAAoB,GACvBlC,IAAI,CAACuD,aAAa,CAAC;MAAEC,IAAI,EAAE;IAAc,CAAC,CAAC,IAAI,CAAC,CAACH,IAAI,CAACI,QAAQ;IAChE,IAAI,CAACpE,QAAQ,GACXW,IAAI,CAAC0D,cAAc,EAAE;IAErB1D,IAAI,CAACE,IAAI,CAACyD,MAAM,KAChB3D,IAAI,CAAC4D,aAAa,oBAAlB5D,IAAI,CAAC4D,aAAa,EAAI;IACxB,IAAI,CAACrE,eAAe,GAAGS,IAAI,CAAC6D,SAAS,EAAE,IAAI7D,IAAI,CAAC8D,QAAQ,EAAE;IAE1D,IAAI,CAACxE,IAAI,GAAG+D,IAAI,CAAC/D,IAAI;IACrB,IAAI,CAACyE,aAAa,0BAGdV,IAAI,CAACU,aAAa,kCAAKV,IAAI,CAASW,OAAO;IAC/C,IAAI,CAACX,IAAI,GAAGA,IAAI;EAClB;EAUArB,YAAY,GAAG;IACb,OAAOnD,SAAS,CAAC,IAAI,CAACwE,IAAI,CAACjE,SAAS,IAAI,IAAI,CAACiE,IAAI,CAACrB,YAAY,EAAE,CAAC;EACnE;EAEAkB,WAAW,GAAG;IACZ,IAAI,IAAI,CAACG,IAAI,CAACI,QAAQ,EAAE,OAAO5E,SAAS,CAAC,IAAI,CAACwE,IAAI,CAACI,QAAQ,CAAC;IAC5D,IAAI,IAAI,CAACJ,IAAI,CAACH,WAAW,EAAE;MACzB,OAAOrE,SAAS,CAAC,IAAI,CAACwE,IAAI,CAACH,WAAW,EAAE,CAAC;IAC3C;EACF;EAEAe,OAAO,GAAG;IAER,IAAI,IAAI,CAACZ,IAAI,CAACa,aAAa,EAAE;MAC3B,IAAI,CAACZ,UAAU,CAAC3D,QAAQ,CAACY,2BAA2B,EAAE;QACpDE,OAAO,EAAE,IAAI,CAAC4C,IAAI,CAACa,aAAa,CAACrD;MACnC,CAAC,CAAC;IACJ;IAEA,MAAMsD,OAAO,GAAG,IAAI,CAACJ,aAAa,GAAGd,aAAa,GAAGlC,YAAY;IAEjE,IAAAqD,0CAA2B,EAAe,IAAI,CAACd,UAAU,EAAE5D,OAAO;MAChEJ,IAAI,EAAE,IAAI,CAACA,IAAI;MACfqB,KAAK,EAAE,IAAI,CAAC2C,UAAU,CAAC3C,KAAK;MAC5BuB,oBAAoB,EAAE,IAAI,CAACA,oBAAoB;MAC/C7C,QAAQ,EAAE,IAAI,CAACA,QAAQ;MACvBE,eAAe,EAAE,IAAI,CAACA,eAAe;MACrCyC,YAAY,EAAE,IAAI,CAACA,YAAY,CAACqC,IAAI,CAAC,IAAI,CAAC;MAC1CnB,WAAW,EAAE,IAAI,CAACA,WAAW,CAACmB,IAAI,CAAC,IAAI,CAAC;MAExCC,QAAQ,EAAEH,OAAO,CAACxC;IAAG,GAClBwC,OAAO,EACV;EACJ;AACF;AAAC"}
=======
<<<<<<< HEAD
{"version":3,"names":["assignmentExpression","booleanLiteral","callExpression","cloneNode","identifier","memberExpression","sequenceExpression","stringLiteral","thisExpression","getPrototypeOfExpression","objectRef","isStatic","file","isPrivateMethod","targetRef","addHelper","visitor","traverse","visitors","merge","environmentVisitor","Super","path","state","node","parentPath","isMemberExpression","object","handle","unshadowSuperBindingVisitor","Scopable","refName","binding","scope","getOwnBinding","name","rename","specHandlers","memoise","superMember","count","computed","property","memo","maybeGenerateMemoised","memoiser","set","prop","has","get","_get","_getThisRefs","thisRefs","proto","getObjectRef","this","isDerivedConstructor","thisRef","generateDeclaredUidIdentifier","value","isInStrictMode","destructureSet","buildCodeFrameError","call","args","optimiseCall","optionalCall","looseHandlers","getSuperRef","ReplaceSupers","constructor","opts","methodPath","isClassMethod","kind","superRef","isObjectMethod","static","isStaticBlock","isPrivate","isMethod","constantSuper","isLoose","replace","refToPreserve","handler","memberExpressionToFunctions","bind","boundGet"],"sources":["../src/index.ts"],"sourcesContent":["import type { NodePath, Scope } from \"@babel/traverse\";\nimport traverse from \"@babel/traverse\";\nimport memberExpressionToFunctions from \"@babel/helper-member-expression-to-functions\";\nimport type { HandlerState } from \"@babel/helper-member-expression-to-functions\";\nimport optimiseCall from \"@babel/helper-optimise-call-expression\";\nimport environmentVisitor from \"@babel/helper-environment-visitor\";\nimport {\n  assignmentExpression,\n  booleanLiteral,\n  callExpression,\n  cloneNode,\n  identifier,\n  memberExpression,\n  sequenceExpression,\n  stringLiteral,\n  thisExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport type { File } from \"@babel/core\";\n\n// TODO (Babel 8): Don't export this.\nexport {\n  default as environmentVisitor,\n  skipAllButComputedKey,\n} from \"@babel/helper-environment-visitor\";\n\ntype ThisRef =\n  | {\n      memo: t.AssignmentExpression;\n      this: t.Identifier;\n    }\n  | { this: t.ThisExpression };\n/**\n * Creates an expression which result is the proto of objectRef.\n *\n * @example <caption>isStatic === true</caption>\n *\n *   helpers.getPrototypeOf(CLASS)\n *\n * @example <caption>isStatic === false</caption>\n *\n *   helpers.getPrototypeOf(CLASS.prototype)\n */\nfunction getPrototypeOfExpression(\n  objectRef: t.Identifier,\n  isStatic: boolean,\n  file: File,\n  isPrivateMethod: boolean,\n) {\n  objectRef = cloneNode(objectRef);\n  const targetRef =\n    isStatic || isPrivateMethod\n      ? objectRef\n      : memberExpression(objectRef, identifier(\"prototype\"));\n\n  return callExpression(file.addHelper(\"getPrototypeOf\"), [targetRef]);\n}\n\nconst visitor = traverse.visitors.merge<\n  HandlerState<ReplaceState> & ReplaceState\n>([\n  environmentVisitor,\n  {\n    Super(path, state) {\n      const { node, parentPath } = path;\n      if (!parentPath.isMemberExpression({ object: node })) return;\n      state.handle(parentPath);\n    },\n  },\n]);\n\nconst unshadowSuperBindingVisitor = traverse.visitors.merge<{\n  refName: string;\n}>([\n  environmentVisitor,\n  {\n    Scopable(path, { refName }) {\n      // https://github.com/Zzzen/babel/pull/1#pullrequestreview-564833183\n      const binding = path.scope.getOwnBinding(refName);\n      if (binding && binding.identifier.name === refName) {\n        path.scope.rename(refName);\n      }\n    },\n  },\n]);\n\ntype SharedState = {\n  file: File;\n  scope: Scope;\n  isDerivedConstructor: boolean;\n  isStatic: boolean;\n  isPrivateMethod: boolean;\n  getObjectRef: () => t.Identifier;\n  getSuperRef: () => t.Identifier;\n  // we dont need boundGet here, but memberExpressionToFunctions handler needs it.\n  boundGet: HandlerState[\"get\"];\n};\n\ntype Handler = HandlerState<SharedState> & SharedState;\ntype SuperMember = NodePath<\n  | t.MemberExpression & {\n      object: t.Super;\n      property: Exclude<t.MemberExpression[\"property\"], t.PrivateName>;\n    }\n>;\n\ninterface SpecHandler\n  extends Pick<\n    Handler,\n    \"get\" | \"set\" | \"destructureSet\" | \"call\" | \"optionalCall\" | \"memoise\"\n  > {\n  _get(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    thisRefs: ThisRef,\n  ): t.CallExpression;\n  _getThisRefs(): ThisRef;\n  prop(this: Handler & SpecHandler, superMember: SuperMember): t.Expression;\n}\n\nconst specHandlers: SpecHandler = {\n  memoise(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    count: number,\n  ) {\n    const { scope, node } = superMember;\n    const { computed, property } = node;\n    if (!computed) {\n      return;\n    }\n\n    const memo = scope.maybeGenerateMemoised(property);\n    if (!memo) {\n      return;\n    }\n\n    this.memoiser.set(property, memo, count);\n  },\n\n  prop(this: Handler & SpecHandler, superMember: SuperMember) {\n    const { computed, property } = superMember.node;\n    if (this.memoiser.has(property)) {\n      return cloneNode(this.memoiser.get(property));\n    }\n\n    if (computed) {\n      return cloneNode(property);\n    }\n\n    return stringLiteral((property as t.Identifier).name);\n  },\n\n  get(this: Handler & SpecHandler, superMember: SuperMember) {\n    return this._get(superMember, this._getThisRefs());\n  },\n\n  _get(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    thisRefs: ThisRef,\n  ) {\n    const proto = getPrototypeOfExpression(\n      this.getObjectRef(),\n      this.isStatic,\n      this.file,\n      this.isPrivateMethod,\n    );\n    return callExpression(this.file.addHelper(\"get\"), [\n      // @ts-expect-error memo does not exist when this.isDerivedConstructor is false\n      thisRefs.memo ? sequenceExpression([thisRefs.memo, proto]) : proto,\n      this.prop(superMember),\n      thisRefs.this,\n    ]);\n  },\n\n  _getThisRefs(this: Handler & SpecHandler): ThisRef {\n    if (!this.isDerivedConstructor) {\n      return { this: thisExpression() };\n    }\n    const thisRef = this.scope.generateDeclaredUidIdentifier(\"thisSuper\");\n    return {\n      memo: assignmentExpression(\"=\", thisRef, thisExpression()),\n      this: cloneNode(thisRef),\n    };\n  },\n\n  set(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    value: t.Expression,\n  ) {\n    const thisRefs = this._getThisRefs();\n    const proto = getPrototypeOfExpression(\n      this.getObjectRef(),\n      this.isStatic,\n      this.file,\n      this.isPrivateMethod,\n    );\n    return callExpression(this.file.addHelper(\"set\"), [\n      // @ts-expect-error memo does not exist when this.isDerivedConstructor is false\n      thisRefs.memo ? sequenceExpression([thisRefs.memo, proto]) : proto,\n      this.prop(superMember),\n      value,\n      thisRefs.this,\n      booleanLiteral(superMember.isInStrictMode()),\n    ]);\n  },\n\n  destructureSet(this: Handler & SpecHandler, superMember: SuperMember) {\n    throw superMember.buildCodeFrameError(\n      `Destructuring to a super field is not supported yet.`,\n    );\n  },\n\n  call(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    args: t.CallExpression[\"arguments\"],\n  ) {\n    const thisRefs = this._getThisRefs();\n    return optimiseCall(\n      this._get(superMember, thisRefs),\n      cloneNode(thisRefs.this),\n      args,\n      false,\n    );\n  },\n\n  optionalCall(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    args: t.CallExpression[\"arguments\"],\n  ) {\n    const thisRefs = this._getThisRefs();\n    return optimiseCall(\n      this._get(superMember, thisRefs),\n      cloneNode(thisRefs.this),\n      args,\n      true,\n    );\n  },\n};\n\nconst looseHandlers = {\n  ...specHandlers,\n\n  prop(this: Handler & typeof specHandlers, superMember: SuperMember) {\n    const { property } = superMember.node;\n    if (this.memoiser.has(property)) {\n      return cloneNode(this.memoiser.get(property));\n    }\n\n    return cloneNode(property);\n  },\n\n  get(this: Handler & typeof specHandlers, superMember: SuperMember) {\n    const { isStatic, getSuperRef } = this;\n    const { computed } = superMember.node;\n    const prop = this.prop(superMember);\n\n    let object;\n    if (isStatic) {\n      object =\n        getSuperRef() ??\n        memberExpression(identifier(\"Function\"), identifier(\"prototype\"));\n    } else {\n      object = memberExpression(\n        getSuperRef() ?? identifier(\"Object\"),\n        identifier(\"prototype\"),\n      );\n    }\n\n    return memberExpression(object, prop, computed);\n  },\n\n  set(\n    this: Handler & typeof specHandlers,\n    superMember: SuperMember,\n    value: t.Expression,\n  ) {\n    const { computed } = superMember.node;\n    const prop = this.prop(superMember);\n\n    return assignmentExpression(\n      \"=\",\n      memberExpression(thisExpression(), prop, computed),\n      value,\n    );\n  },\n\n  destructureSet(\n    this: Handler & typeof specHandlers,\n    superMember: SuperMember,\n  ) {\n    const { computed } = superMember.node;\n    const prop = this.prop(superMember);\n\n    return memberExpression(thisExpression(), prop, computed);\n  },\n\n  call(\n    this: Handler & typeof specHandlers,\n    superMember: SuperMember,\n    args: t.CallExpression[\"arguments\"],\n  ) {\n    return optimiseCall(this.get(superMember), thisExpression(), args, false);\n  },\n\n  optionalCall(\n    this: Handler & typeof specHandlers,\n    superMember: SuperMember,\n    args: t.CallExpression[\"arguments\"],\n  ) {\n    return optimiseCall(this.get(superMember), thisExpression(), args, true);\n  },\n};\n\ntype ReplaceSupersOptionsBase = {\n  methodPath: NodePath<\n    | t.ClassMethod\n    | t.ClassProperty\n    | t.ObjectMethod\n    | t.ClassPrivateMethod\n    | t.ClassPrivateProperty\n    | t.StaticBlock\n  >;\n  constantSuper?: boolean;\n  file: File;\n  // objectRef might have been shadowed in child scopes,\n  // in that case, we need to rename related variables.\n  refToPreserve?: t.Identifier;\n};\n\ntype ReplaceSupersOptions = ReplaceSupersOptionsBase &\n  (\n    | { objectRef?: undefined; getObjectRef: () => t.Node }\n    | { objectRef: t.Node; getObjectRef?: undefined }\n  ) &\n  (\n    | { superRef?: undefined; getSuperRef: () => t.Node }\n    | { superRef: t.Node; getSuperRef?: undefined }\n  );\n\ninterface ReplaceState {\n  file: File;\n  scope: Scope;\n  isDerivedConstructor: boolean;\n  isStatic: boolean;\n  isPrivateMethod: boolean;\n  getObjectRef: ReplaceSupers[\"getObjectRef\"];\n  getSuperRef: ReplaceSupers[\"getSuperRef\"];\n}\n\nexport default class ReplaceSupers {\n  constructor(opts: ReplaceSupersOptions) {\n    const path = opts.methodPath;\n\n    this.methodPath = path;\n    this.isDerivedConstructor =\n      path.isClassMethod({ kind: \"constructor\" }) && !!opts.superRef;\n    this.isStatic =\n      path.isObjectMethod() ||\n      // @ts-expect-error static is not in ClassPrivateMethod\n      path.node.static ||\n      path.isStaticBlock?.();\n    this.isPrivateMethod = path.isPrivate() && path.isMethod();\n\n    this.file = opts.file;\n    this.constantSuper = process.env.BABEL_8_BREAKING\n      ? opts.constantSuper\n      : // Fallback to isLoose for backward compatibility\n        opts.constantSuper ?? (opts as any).isLoose;\n    this.opts = opts;\n  }\n\n  declare file: File;\n  declare isDerivedConstructor: boolean;\n  declare constantSuper: boolean;\n  declare isPrivateMethod: boolean;\n  declare isStatic: boolean;\n  declare methodPath: NodePath;\n  declare opts: ReplaceSupersOptions;\n\n  getObjectRef() {\n    return cloneNode(this.opts.objectRef || this.opts.getObjectRef());\n  }\n\n  getSuperRef() {\n    if (this.opts.superRef) return cloneNode(this.opts.superRef);\n    if (this.opts.getSuperRef) {\n      return cloneNode(this.opts.getSuperRef());\n    }\n  }\n\n  replace() {\n    // https://github.com/babel/babel/issues/11994\n    if (this.opts.refToPreserve) {\n      this.methodPath.traverse(unshadowSuperBindingVisitor, {\n        refName: this.opts.refToPreserve.name,\n      });\n    }\n\n    const handler = this.constantSuper ? looseHandlers : specHandlers;\n\n    memberExpressionToFunctions<ReplaceState>(this.methodPath, visitor, {\n      file: this.file,\n      scope: this.methodPath.scope,\n      isDerivedConstructor: this.isDerivedConstructor,\n      isStatic: this.isStatic,\n      isPrivateMethod: this.isPrivateMethod,\n      getObjectRef: this.getObjectRef.bind(this),\n      getSuperRef: this.getSuperRef.bind(this),\n      // we dont need boundGet here, but memberExpressionToFunctions handler needs it.\n      boundGet: handler.get,\n      ...handler,\n    });\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;AACA;;AACA;;AAEA;;AACA;;AACA;;;EACEA,oB;EACAC,c;EACAC,c;EACAC,S;EACAC,U;EACAC,gB;EACAC,kB;EACAC,a;EACAC;;;AA4BF,SAASC,wBAAT,CACEC,SADF,EAEEC,QAFF,EAGEC,IAHF,EAIEC,eAJF,EAKE;EACAH,SAAS,GAAGP,SAAS,CAACO,SAAD,CAArB;EACA,MAAMI,SAAS,GACbH,QAAQ,IAAIE,eAAZ,GACIH,SADJ,GAEIL,gBAAgB,CAACK,SAAD,EAAYN,UAAU,CAAC,WAAD,CAAtB,CAHtB;EAKA,OAAOF,cAAc,CAACU,IAAI,CAACG,SAAL,CAAe,gBAAf,CAAD,EAAmC,CAACD,SAAD,CAAnC,CAArB;AACD;;AAED,MAAME,OAAO,GAAGC,iBAAA,CAASC,QAAT,CAAkBC,KAAlB,CAEd,CACAC,iCADA,EAEA;EACEC,KAAK,CAACC,IAAD,EAAOC,KAAP,EAAc;IACjB,MAAM;MAAEC,IAAF;MAAQC;IAAR,IAAuBH,IAA7B;IACA,IAAI,CAACG,UAAU,CAACC,kBAAX,CAA8B;MAAEC,MAAM,EAAEH;IAAV,CAA9B,CAAL,EAAsD;IACtDD,KAAK,CAACK,MAAN,CAAaH,UAAb;EACD;;AALH,CAFA,CAFc,CAAhB;;AAaA,MAAMI,2BAA2B,GAAGZ,iBAAA,CAASC,QAAT,CAAkBC,KAAlB,CAEjC,CACDC,iCADC,EAED;EACEU,QAAQ,CAACR,IAAD,EAAO;IAAES;EAAF,CAAP,EAAoB;IAE1B,MAAMC,OAAO,GAAGV,IAAI,CAACW,KAAL,CAAWC,aAAX,CAAyBH,OAAzB,CAAhB;;IACA,IAAIC,OAAO,IAAIA,OAAO,CAAC5B,UAAR,CAAmB+B,IAAnB,KAA4BJ,OAA3C,EAAoD;MAClDT,IAAI,CAACW,KAAL,CAAWG,MAAX,CAAkBL,OAAlB;IACD;EACF;;AAPH,CAFC,CAFiC,CAApC;;AAiDA,MAAMM,YAAyB,GAAG;EAChCC,OAAO,CAELC,WAFK,EAGLC,KAHK,EAIL;IACA,MAAM;MAAEP,KAAF;MAAST;IAAT,IAAkBe,WAAxB;IACA,MAAM;MAAEE,QAAF;MAAYC;IAAZ,IAAyBlB,IAA/B;;IACA,IAAI,CAACiB,QAAL,EAAe;MACb;IACD;;IAED,MAAME,IAAI,GAAGV,KAAK,CAACW,qBAAN,CAA4BF,QAA5B,CAAb;;IACA,IAAI,CAACC,IAAL,EAAW;MACT;IACD;;IAED,KAAKE,QAAL,CAAcC,GAAd,CAAkBJ,QAAlB,EAA4BC,IAA5B,EAAkCH,KAAlC;EACD,CAlB+B;;EAoBhCO,IAAI,CAA8BR,WAA9B,EAAwD;IAC1D,MAAM;MAAEE,QAAF;MAAYC;IAAZ,IAAyBH,WAAW,CAACf,IAA3C;;IACA,IAAI,KAAKqB,QAAL,CAAcG,GAAd,CAAkBN,QAAlB,CAAJ,EAAiC;MAC/B,OAAOvC,SAAS,CAAC,KAAK0C,QAAL,CAAcI,GAAd,CAAkBP,QAAlB,CAAD,CAAhB;IACD;;IAED,IAAID,QAAJ,EAAc;MACZ,OAAOtC,SAAS,CAACuC,QAAD,CAAhB;IACD;;IAED,OAAOnC,aAAa,CAAEmC,QAAD,CAA2BP,IAA5B,CAApB;EACD,CA/B+B;;EAiChCc,GAAG,CAA8BV,WAA9B,EAAwD;IACzD,OAAO,KAAKW,IAAL,CAAUX,WAAV,EAAuB,KAAKY,YAAL,EAAvB,CAAP;EACD,CAnC+B;;EAqChCD,IAAI,CAEFX,WAFE,EAGFa,QAHE,EAIF;IACA,MAAMC,KAAK,GAAG5C,wBAAwB,CACpC,KAAK6C,YAAL,EADoC,EAEpC,KAAK3C,QAF+B,EAGpC,KAAKC,IAH+B,EAIpC,KAAKC,eAJ+B,CAAtC;IAMA,OAAOX,cAAc,CAAC,KAAKU,IAAL,CAAUG,SAAV,CAAoB,KAApB,CAAD,EAA6B,CAEhDqC,QAAQ,CAACT,IAAT,GAAgBrC,kBAAkB,CAAC,CAAC8C,QAAQ,CAACT,IAAV,EAAgBU,KAAhB,CAAD,CAAlC,GAA6DA,KAFb,EAGhD,KAAKN,IAAL,CAAUR,WAAV,CAHgD,EAIhDa,QAAQ,CAACG,IAJuC,CAA7B,CAArB;EAMD,CAtD+B;;EAwDhCJ,YAAY,GAAuC;IACjD,IAAI,CAAC,KAAKK,oBAAV,EAAgC;MAC9B,OAAO;QAAED,IAAI,EAAE/C,cAAc;MAAtB,CAAP;IACD;;IACD,MAAMiD,OAAO,GAAG,KAAKxB,KAAL,CAAWyB,6BAAX,CAAyC,WAAzC,CAAhB;IACA,OAAO;MACLf,IAAI,EAAE3C,oBAAoB,CAAC,GAAD,EAAMyD,OAAN,EAAejD,cAAc,EAA7B,CADrB;MAEL+C,IAAI,EAAEpD,SAAS,CAACsD,OAAD;IAFV,CAAP;EAID,CAjE+B;;EAmEhCX,GAAG,CAEDP,WAFC,EAGDoB,KAHC,EAID;IACA,MAAMP,QAAQ,GAAG,KAAKD,YAAL,EAAjB;;IACA,MAAME,KAAK,GAAG5C,wBAAwB,CACpC,KAAK6C,YAAL,EADoC,EAEpC,KAAK3C,QAF+B,EAGpC,KAAKC,IAH+B,EAIpC,KAAKC,eAJ+B,CAAtC;IAMA,OAAOX,cAAc,CAAC,KAAKU,IAAL,CAAUG,SAAV,CAAoB,KAApB,CAAD,EAA6B,CAEhDqC,QAAQ,CAACT,IAAT,GAAgBrC,kBAAkB,CAAC,CAAC8C,QAAQ,CAACT,IAAV,EAAgBU,KAAhB,CAAD,CAAlC,GAA6DA,KAFb,EAGhD,KAAKN,IAAL,CAAUR,WAAV,CAHgD,EAIhDoB,KAJgD,EAKhDP,QAAQ,CAACG,IALuC,EAMhDtD,cAAc,CAACsC,WAAW,CAACqB,cAAZ,EAAD,CANkC,CAA7B,CAArB;EAQD,CAvF+B;;EAyFhCC,cAAc,CAA8BtB,WAA9B,EAAwD;IACpE,MAAMA,WAAW,CAACuB,mBAAZ,CACH,sDADG,CAAN;EAGD,CA7F+B;;EA+FhCC,IAAI,CAEFxB,WAFE,EAGFyB,IAHE,EAIF;IACA,MAAMZ,QAAQ,GAAG,KAAKD,YAAL,EAAjB;;IACA,OAAO,IAAAc,qCAAA,EACL,KAAKf,IAAL,CAAUX,WAAV,EAAuBa,QAAvB,CADK,EAELjD,SAAS,CAACiD,QAAQ,CAACG,IAAV,CAFJ,EAGLS,IAHK,EAIL,KAJK,CAAP;EAMD,CA3G+B;;EA6GhCE,YAAY,CAEV3B,WAFU,EAGVyB,IAHU,EAIV;IACA,MAAMZ,QAAQ,GAAG,KAAKD,YAAL,EAAjB;;IACA,OAAO,IAAAc,qCAAA,EACL,KAAKf,IAAL,CAAUX,WAAV,EAAuBa,QAAvB,CADK,EAELjD,SAAS,CAACiD,QAAQ,CAACG,IAAV,CAFJ,EAGLS,IAHK,EAIL,IAJK,CAAP;EAMD;;AAzH+B,CAAlC;AA4HA,MAAMG,aAAa,qBACd9B,YADc;EAGjBU,IAAI,CAAsCR,WAAtC,EAAgE;IAClE,MAAM;MAAEG;IAAF,IAAeH,WAAW,CAACf,IAAjC;;IACA,IAAI,KAAKqB,QAAL,CAAcG,GAAd,CAAkBN,QAAlB,CAAJ,EAAiC;MAC/B,OAAOvC,SAAS,CAAC,KAAK0C,QAAL,CAAcI,GAAd,CAAkBP,QAAlB,CAAD,CAAhB;IACD;;IAED,OAAOvC,SAAS,CAACuC,QAAD,CAAhB;EACD,CAVgB;;EAYjBO,GAAG,CAAsCV,WAAtC,EAAgE;IACjE,MAAM;MAAE5B,QAAF;MAAYyD;IAAZ,IAA4B,IAAlC;IACA,MAAM;MAAE3B;IAAF,IAAeF,WAAW,CAACf,IAAjC;IACA,MAAMuB,IAAI,GAAG,KAAKA,IAAL,CAAUR,WAAV,CAAb;IAEA,IAAIZ,MAAJ;;IACA,IAAIhB,QAAJ,EAAc;MAAA;;MACZgB,MAAM,mBACJyC,WAAW,EADP,2BAEJ/D,gBAAgB,CAACD,UAAU,CAAC,UAAD,CAAX,EAAyBA,UAAU,CAAC,WAAD,CAAnC,CAFlB;IAGD,CAJD,MAIO;MAAA;;MACLuB,MAAM,GAAGtB,gBAAgB,kBACvB+D,WAAW,EADY,4BACNhE,UAAU,CAAC,QAAD,CADJ,EAEvBA,UAAU,CAAC,WAAD,CAFa,CAAzB;IAID;;IAED,OAAOC,gBAAgB,CAACsB,MAAD,EAASoB,IAAT,EAAeN,QAAf,CAAvB;EACD,CA9BgB;;EAgCjBK,GAAG,CAEDP,WAFC,EAGDoB,KAHC,EAID;IACA,MAAM;MAAElB;IAAF,IAAeF,WAAW,CAACf,IAAjC;IACA,MAAMuB,IAAI,GAAG,KAAKA,IAAL,CAAUR,WAAV,CAAb;IAEA,OAAOvC,oBAAoB,CACzB,GADyB,EAEzBK,gBAAgB,CAACG,cAAc,EAAf,EAAmBuC,IAAnB,EAAyBN,QAAzB,CAFS,EAGzBkB,KAHyB,CAA3B;EAKD,CA7CgB;;EA+CjBE,cAAc,CAEZtB,WAFY,EAGZ;IACA,MAAM;MAAEE;IAAF,IAAeF,WAAW,CAACf,IAAjC;IACA,MAAMuB,IAAI,GAAG,KAAKA,IAAL,CAAUR,WAAV,CAAb;IAEA,OAAOlC,gBAAgB,CAACG,cAAc,EAAf,EAAmBuC,IAAnB,EAAyBN,QAAzB,CAAvB;EACD,CAvDgB;;EAyDjBsB,IAAI,CAEFxB,WAFE,EAGFyB,IAHE,EAIF;IACA,OAAO,IAAAC,qCAAA,EAAa,KAAKhB,GAAL,CAASV,WAAT,CAAb,EAAoC/B,cAAc,EAAlD,EAAsDwD,IAAtD,EAA4D,KAA5D,CAAP;EACD,CA/DgB;;EAiEjBE,YAAY,CAEV3B,WAFU,EAGVyB,IAHU,EAIV;IACA,OAAO,IAAAC,qCAAA,EAAa,KAAKhB,GAAL,CAASV,WAAT,CAAb,EAAoC/B,cAAc,EAAlD,EAAsDwD,IAAtD,EAA4D,IAA5D,CAAP;EACD;;AAvEgB,EAAnB;;AA8Ge,MAAMK,aAAN,CAAoB;EACjCC,WAAW,CAACC,IAAD,EAA6B;IAAA;;IACtC,MAAMjD,IAAI,GAAGiD,IAAI,CAACC,UAAlB;IAEA,KAAKA,UAAL,GAAkBlD,IAAlB;IACA,KAAKkC,oBAAL,GACElC,IAAI,CAACmD,aAAL,CAAmB;MAAEC,IAAI,EAAE;IAAR,CAAnB,KAA+C,CAAC,CAACH,IAAI,CAACI,QADxD;IAEA,KAAKhE,QAAL,GACEW,IAAI,CAACsD,cAAL,MAEAtD,IAAI,CAACE,IAAL,CAAUqD,MAFV,KAGAvD,IAAI,CAACwD,aAHL,oBAGAxD,IAAI,CAACwD,aAAL,EAHA,CADF;IAKA,KAAKjE,eAAL,GAAuBS,IAAI,CAACyD,SAAL,MAAoBzD,IAAI,CAAC0D,QAAL,EAA3C;IAEA,KAAKpE,IAAL,GAAY2D,IAAI,CAAC3D,IAAjB;IACA,KAAKqE,aAAL,0BAGIV,IAAI,CAACU,aAHT,kCAG2BV,IAAD,CAAcW,OAHxC;IAIA,KAAKX,IAAL,GAAYA,IAAZ;EACD;;EAUDjB,YAAY,GAAG;IACb,OAAOnD,SAAS,CAAC,KAAKoE,IAAL,CAAU7D,SAAV,IAAuB,KAAK6D,IAAL,CAAUjB,YAAV,EAAxB,CAAhB;EACD;;EAEDc,WAAW,GAAG;IACZ,IAAI,KAAKG,IAAL,CAAUI,QAAd,EAAwB,OAAOxE,SAAS,CAAC,KAAKoE,IAAL,CAAUI,QAAX,CAAhB;;IACxB,IAAI,KAAKJ,IAAL,CAAUH,WAAd,EAA2B;MACzB,OAAOjE,SAAS,CAAC,KAAKoE,IAAL,CAAUH,WAAV,EAAD,CAAhB;IACD;EACF;;EAEDe,OAAO,GAAG;IAER,IAAI,KAAKZ,IAAL,CAAUa,aAAd,EAA6B;MAC3B,KAAKZ,UAAL,CAAgBvD,QAAhB,CAAyBY,2BAAzB,EAAsD;QACpDE,OAAO,EAAE,KAAKwC,IAAL,CAAUa,aAAV,CAAwBjD;MADmB,CAAtD;IAGD;;IAED,MAAMkD,OAAO,GAAG,KAAKJ,aAAL,GAAqBd,aAArB,GAAqC9B,YAArD;IAEA,IAAAiD,0CAAA,EAA0C,KAAKd,UAA/C,EAA2DxD,OAA3D;MACEJ,IAAI,EAAE,KAAKA,IADb;MAEEqB,KAAK,EAAE,KAAKuC,UAAL,CAAgBvC,KAFzB;MAGEuB,oBAAoB,EAAE,KAAKA,oBAH7B;MAIE7C,QAAQ,EAAE,KAAKA,QAJjB;MAKEE,eAAe,EAAE,KAAKA,eALxB;MAMEyC,YAAY,EAAE,KAAKA,YAAL,CAAkBiC,IAAlB,CAAuB,IAAvB,CANhB;MAOEnB,WAAW,EAAE,KAAKA,WAAL,CAAiBmB,IAAjB,CAAsB,IAAtB,CAPf;MASEC,QAAQ,EAAEH,OAAO,CAACpC;IATpB,GAUKoC,OAVL;EAYD;;AA/DgC"}
=======
{"version":3,"names":["assignmentExpression","booleanLiteral","callExpression","cloneNode","identifier","memberExpression","sequenceExpression","stringLiteral","thisExpression","getPrototypeOfExpression","objectRef","isStatic","file","isPrivateMethod","targetRef","addHelper","visitor","traverse","visitors","merge","environmentVisitor","Super","path","state","node","parentPath","isMemberExpression","object","handle","unshadowSuperBindingVisitor","Scopable","refName","binding","scope","getOwnBinding","name","rename","specHandlers","memoise","superMember","count","computed","property","memo","maybeGenerateMemoised","memoiser","set","prop","has","get","_get","_getThisRefs","thisRefs","proto","getObjectRef","this","isDerivedConstructor","thisRef","generateDeclaredUidIdentifier","value","isInStrictMode","destructureSet","buildCodeFrameError","call","args","optimiseCall","optionalCall","delete","template","expression","ast","looseHandlers","getSuperRef","ReplaceSupers","constructor","opts","methodPath","isClassMethod","kind","superRef","isObjectMethod","static","isStaticBlock","isPrivate","isMethod","constantSuper","isLoose","replace","refToPreserve","handler","memberExpressionToFunctions","bind","boundGet"],"sources":["../src/index.ts"],"sourcesContent":["import type { File } from \"@babel/core\";\nimport environmentVisitor from \"@babel/helper-environment-visitor\";\nimport memberExpressionToFunctions from \"@babel/helper-member-expression-to-functions\";\nimport type { HandlerState } from \"@babel/helper-member-expression-to-functions\";\nimport optimiseCall from \"@babel/helper-optimise-call-expression\";\nimport template from \"@babel/template\";\nimport traverse from \"@babel/traverse\";\nimport type { NodePath, Scope } from \"@babel/traverse\";\nimport {\n  assignmentExpression,\n  booleanLiteral,\n  callExpression,\n  cloneNode,\n  identifier,\n  memberExpression,\n  sequenceExpression,\n  stringLiteral,\n  thisExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\n// TODO (Babel 8): Don't export this.\nexport {\n  default as environmentVisitor,\n  skipAllButComputedKey,\n} from \"@babel/helper-environment-visitor\";\n\ntype ThisRef =\n  | {\n      memo: t.AssignmentExpression;\n      this: t.Identifier;\n    }\n  | { this: t.ThisExpression };\n/**\n * Creates an expression which result is the proto of objectRef.\n *\n * @example <caption>isStatic === true</caption>\n *\n *   helpers.getPrototypeOf(CLASS)\n *\n * @example <caption>isStatic === false</caption>\n *\n *   helpers.getPrototypeOf(CLASS.prototype)\n */\nfunction getPrototypeOfExpression(\n  objectRef: t.Identifier,\n  isStatic: boolean,\n  file: File,\n  isPrivateMethod: boolean,\n) {\n  objectRef = cloneNode(objectRef);\n  const targetRef =\n    isStatic || isPrivateMethod\n      ? objectRef\n      : memberExpression(objectRef, identifier(\"prototype\"));\n\n  return callExpression(file.addHelper(\"getPrototypeOf\"), [targetRef]);\n}\n\nconst visitor = traverse.visitors.merge<\n  HandlerState<ReplaceState> & ReplaceState\n>([\n  environmentVisitor,\n  {\n    Super(path, state) {\n      const { node, parentPath } = path;\n      if (!parentPath.isMemberExpression({ object: node })) return;\n      state.handle(parentPath);\n    },\n  },\n]);\n\nconst unshadowSuperBindingVisitor = traverse.visitors.merge<{\n  refName: string;\n}>([\n  environmentVisitor,\n  {\n    Scopable(path, { refName }) {\n      // https://github.com/Zzzen/babel/pull/1#pullrequestreview-564833183\n      const binding = path.scope.getOwnBinding(refName);\n      if (binding && binding.identifier.name === refName) {\n        path.scope.rename(refName);\n      }\n    },\n  },\n]);\n\ntype SharedState = {\n  file: File;\n  scope: Scope;\n  isDerivedConstructor: boolean;\n  isStatic: boolean;\n  isPrivateMethod: boolean;\n  getObjectRef: () => t.Identifier;\n  getSuperRef: () => t.Identifier;\n  // we dont need boundGet here, but memberExpressionToFunctions handler needs it.\n  boundGet: HandlerState[\"get\"];\n};\n\ntype Handler = HandlerState<SharedState> & SharedState;\ntype SuperMember = NodePath<\n  | t.MemberExpression & {\n      object: t.Super;\n      property: Exclude<t.MemberExpression[\"property\"], t.PrivateName>;\n    }\n>;\n\ninterface SpecHandler\n  extends Pick<\n    Handler,\n    | \"memoise\"\n    | \"get\"\n    | \"set\"\n    | \"destructureSet\"\n    | \"call\"\n    | \"optionalCall\"\n    | \"delete\"\n  > {\n  _get(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    thisRefs: ThisRef,\n  ): t.CallExpression;\n  _getThisRefs(): ThisRef;\n  prop(this: Handler & SpecHandler, superMember: SuperMember): t.Expression;\n}\n\nconst specHandlers: SpecHandler = {\n  memoise(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    count: number,\n  ) {\n    const { scope, node } = superMember;\n    const { computed, property } = node;\n    if (!computed) {\n      return;\n    }\n\n    const memo = scope.maybeGenerateMemoised(property);\n    if (!memo) {\n      return;\n    }\n\n    this.memoiser.set(property, memo, count);\n  },\n\n  prop(this: Handler & SpecHandler, superMember: SuperMember) {\n    const { computed, property } = superMember.node;\n    if (this.memoiser.has(property)) {\n      return cloneNode(this.memoiser.get(property));\n    }\n\n    if (computed) {\n      return cloneNode(property);\n    }\n\n    return stringLiteral((property as t.Identifier).name);\n  },\n\n  get(this: Handler & SpecHandler, superMember: SuperMember) {\n    return this._get(superMember, this._getThisRefs());\n  },\n\n  _get(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    thisRefs: ThisRef,\n  ) {\n    const proto = getPrototypeOfExpression(\n      this.getObjectRef(),\n      this.isStatic,\n      this.file,\n      this.isPrivateMethod,\n    );\n    return callExpression(this.file.addHelper(\"get\"), [\n      // @ts-expect-error memo does not exist when this.isDerivedConstructor is false\n      thisRefs.memo ? sequenceExpression([thisRefs.memo, proto]) : proto,\n      this.prop(superMember),\n      thisRefs.this,\n    ]);\n  },\n\n  _getThisRefs(this: Handler & SpecHandler): ThisRef {\n    if (!this.isDerivedConstructor) {\n      return { this: thisExpression() };\n    }\n    const thisRef = this.scope.generateDeclaredUidIdentifier(\"thisSuper\");\n    return {\n      memo: assignmentExpression(\"=\", thisRef, thisExpression()),\n      this: cloneNode(thisRef),\n    };\n  },\n\n  set(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    value: t.Expression,\n  ) {\n    const thisRefs = this._getThisRefs();\n    const proto = getPrototypeOfExpression(\n      this.getObjectRef(),\n      this.isStatic,\n      this.file,\n      this.isPrivateMethod,\n    );\n    return callExpression(this.file.addHelper(\"set\"), [\n      // @ts-expect-error memo does not exist when this.isDerivedConstructor is false\n      thisRefs.memo ? sequenceExpression([thisRefs.memo, proto]) : proto,\n      this.prop(superMember),\n      value,\n      thisRefs.this,\n      booleanLiteral(superMember.isInStrictMode()),\n    ]);\n  },\n\n  destructureSet(this: Handler & SpecHandler, superMember: SuperMember) {\n    throw superMember.buildCodeFrameError(\n      `Destructuring to a super field is not supported yet.`,\n    );\n  },\n\n  call(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    args: t.CallExpression[\"arguments\"],\n  ) {\n    const thisRefs = this._getThisRefs();\n    return optimiseCall(\n      this._get(superMember, thisRefs),\n      cloneNode(thisRefs.this),\n      args,\n      false,\n    );\n  },\n\n  optionalCall(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    args: t.CallExpression[\"arguments\"],\n  ) {\n    const thisRefs = this._getThisRefs();\n    return optimiseCall(\n      this._get(superMember, thisRefs),\n      cloneNode(thisRefs.this),\n      args,\n      true,\n    );\n  },\n\n  delete(this: Handler & SpecHandler, superMember: SuperMember) {\n    if (superMember.node.computed) {\n      return sequenceExpression([\n        callExpression(this.file.addHelper(\"toPropertyKey\"), [\n          cloneNode(superMember.node.property),\n        ]),\n        template.expression.ast`\n          function () { throw new ReferenceError(\"'delete super[expr]' is invalid\"); }()\n        `,\n      ]);\n    } else {\n      return template.expression.ast`\n        function () { throw new ReferenceError(\"'delete super.prop' is invalid\"); }()\n      `;\n    }\n  },\n};\n\nconst looseHandlers = {\n  ...specHandlers,\n\n  prop(this: Handler & typeof specHandlers, superMember: SuperMember) {\n    const { property } = superMember.node;\n    if (this.memoiser.has(property)) {\n      return cloneNode(this.memoiser.get(property));\n    }\n\n    return cloneNode(property);\n  },\n\n  get(this: Handler & typeof specHandlers, superMember: SuperMember) {\n    const { isStatic, getSuperRef } = this;\n    const { computed } = superMember.node;\n    const prop = this.prop(superMember);\n\n    let object;\n    if (isStatic) {\n      object =\n        getSuperRef() ??\n        memberExpression(identifier(\"Function\"), identifier(\"prototype\"));\n    } else {\n      object = memberExpression(\n        getSuperRef() ?? identifier(\"Object\"),\n        identifier(\"prototype\"),\n      );\n    }\n\n    return memberExpression(object, prop, computed);\n  },\n\n  set(\n    this: Handler & typeof specHandlers,\n    superMember: SuperMember,\n    value: t.Expression,\n  ) {\n    const { computed } = superMember.node;\n    const prop = this.prop(superMember);\n\n    return assignmentExpression(\n      \"=\",\n      memberExpression(thisExpression(), prop, computed),\n      value,\n    );\n  },\n\n  destructureSet(\n    this: Handler & typeof specHandlers,\n    superMember: SuperMember,\n  ) {\n    const { computed } = superMember.node;\n    const prop = this.prop(superMember);\n\n    return memberExpression(thisExpression(), prop, computed);\n  },\n\n  call(\n    this: Handler & typeof specHandlers,\n    superMember: SuperMember,\n    args: t.CallExpression[\"arguments\"],\n  ) {\n    return optimiseCall(this.get(superMember), thisExpression(), args, false);\n  },\n\n  optionalCall(\n    this: Handler & typeof specHandlers,\n    superMember: SuperMember,\n    args: t.CallExpression[\"arguments\"],\n  ) {\n    return optimiseCall(this.get(superMember), thisExpression(), args, true);\n  },\n};\n\ntype ReplaceSupersOptionsBase = {\n  methodPath: NodePath<\n    | t.ClassMethod\n    | t.ClassProperty\n    | t.ObjectMethod\n    | t.ClassPrivateMethod\n    | t.ClassPrivateProperty\n    | t.StaticBlock\n  >;\n  constantSuper?: boolean;\n  file: File;\n  // objectRef might have been shadowed in child scopes,\n  // in that case, we need to rename related variables.\n  refToPreserve?: t.Identifier;\n};\n\ntype ReplaceSupersOptions = ReplaceSupersOptionsBase &\n  (\n    | { objectRef?: undefined; getObjectRef: () => t.Node }\n    | { objectRef: t.Node; getObjectRef?: undefined }\n  ) &\n  (\n    | { superRef?: undefined; getSuperRef: () => t.Node }\n    | { superRef: t.Node; getSuperRef?: undefined }\n  );\n\ninterface ReplaceState {\n  file: File;\n  scope: Scope;\n  isDerivedConstructor: boolean;\n  isStatic: boolean;\n  isPrivateMethod: boolean;\n  getObjectRef: ReplaceSupers[\"getObjectRef\"];\n  getSuperRef: ReplaceSupers[\"getSuperRef\"];\n}\n\nexport default class ReplaceSupers {\n  constructor(opts: ReplaceSupersOptions) {\n    const path = opts.methodPath;\n\n    this.methodPath = path;\n    this.isDerivedConstructor =\n      path.isClassMethod({ kind: \"constructor\" }) && !!opts.superRef;\n    this.isStatic =\n      path.isObjectMethod() ||\n      // @ts-expect-error static is not in ClassPrivateMethod\n      path.node.static ||\n      path.isStaticBlock?.();\n    this.isPrivateMethod = path.isPrivate() && path.isMethod();\n\n    this.file = opts.file;\n    this.constantSuper = process.env.BABEL_8_BREAKING\n      ? opts.constantSuper\n      : // Fallback to isLoose for backward compatibility\n        opts.constantSuper ?? (opts as any).isLoose;\n    this.opts = opts;\n  }\n\n  declare file: File;\n  declare isDerivedConstructor: boolean;\n  declare constantSuper: boolean;\n  declare isPrivateMethod: boolean;\n  declare isStatic: boolean;\n  declare methodPath: NodePath;\n  declare opts: ReplaceSupersOptions;\n\n  getObjectRef() {\n    return cloneNode(this.opts.objectRef || this.opts.getObjectRef());\n  }\n\n  getSuperRef() {\n    if (this.opts.superRef) return cloneNode(this.opts.superRef);\n    if (this.opts.getSuperRef) {\n      return cloneNode(this.opts.getSuperRef());\n    }\n  }\n\n  replace() {\n    // https://github.com/babel/babel/issues/11994\n    if (this.opts.refToPreserve) {\n      this.methodPath.traverse(unshadowSuperBindingVisitor, {\n        refName: this.opts.refToPreserve.name,\n      });\n    }\n\n    const handler = this.constantSuper ? looseHandlers : specHandlers;\n\n    memberExpressionToFunctions<ReplaceState>(this.methodPath, visitor, {\n      file: this.file,\n      scope: this.methodPath.scope,\n      isDerivedConstructor: this.isDerivedConstructor,\n      isStatic: this.isStatic,\n      isPrivateMethod: this.isPrivateMethod,\n      getObjectRef: this.getObjectRef.bind(this),\n      getSuperRef: this.getSuperRef.bind(this),\n      // we dont need boundGet here, but memberExpressionToFunctions handler needs it.\n      boundGet: handler.get,\n      ...handler,\n    });\n  }\n}\n"],"mappings":"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"}
>>>>>>> zen
>>>>>>> ede5c2d510e1c4029dfffa203387bb3f20d74fc6
