<<<<<<< HEAD
{"version":3,"names":["DEFAULT","importSource","runtime","pragma","pragmaFrag","JSX_SOURCE_ANNOTATION_REGEX","JSX_RUNTIME_ANNOTATION_REGEX","JSX_ANNOTATION_REGEX","JSX_FRAG_ANNOTATION_REGEX","get","pass","name","set","v","hasProto","node","properties","some","value","t","isObjectProperty","computed","shorthand","isIdentifier","key","isStringLiteral","createPlugin","development","declare","_","options","pure","PURE_ANNOTATION","throwIfNamespace","filter","RUNTIME_DEFAULT","IMPORT_SOURCE_DEFAULT","PRAGMA_DEFAULT","PRAGMA_FRAG_DEFAULT","useSpread","useBuiltIns","Error","injectMetaPropertiesVisitor","JSXOpeningElement","path","state","attributes","isThisAllowed","scope","push","jsxAttribute","jsxIdentifier","jsxExpressionContainer","thisExpression","makeSource","pushContainer","inherits","jsx","visitor","JSXNamespacedName","buildCodeFrameError","JSXSpreadChild","Program","enter","file","source","sourceSet","pragmaSet","pragmaFragSet","ast","comments","comment","sourceMatches","exec","runtimeMatches","jsxMatches","jsxFragMatches","createElement","toMemberExpression","fragment","cloneNode","define","id","createImportLazily","traverse","JSXFragment","exit","callExpr","buildCreateElementFragmentCall","buildJSXFragmentCall","replaceWith","JSXElement","shouldUseCreateElement","buildCreateElementCall","buildJSXElementCall","JSXAttribute","isJSXElement","isDerivedClass","classPath","superClass","isFunctionParent","isArrowFunctionExpression","isMethod","kind","parentPath","isTSModuleBlock","parent","call","args","callExpression","annotateAsPure","openingPath","seenPropsSpread","i","length","attr","isJSXAttribute","isJSXSpreadAttribute","convertJSXIdentifier","isJSXIdentifier","isReferenced","isValidIdentifier","type","stringLiteral","isJSXMemberExpression","memberExpression","object","property","isJSXNamespacedName","namespace","convertAttributeValue","isJSXExpressionContainer","expression","accumulateAttribute","array","attribute","arg","argument","isObjectExpression","spreadElement","booleanLiteral","replace","extra","raw","objectProperty","buildChildrenProperty","children","childrenNode","arrayExpression","undefined","identifier","getTag","attribsArray","extracted","Object","create","sourceSelfError","keyValue","react","buildChildren","attribs","buildJSXOpeningElementAttributes","objectExpression","buildUndefinedNode","__source","__self","props","reduce","nullLiteral","buildCreateElementOpeningElementAttributes","tagExpr","tagName","isCompatTag","objs","start","forEach","prop","isSpreadElement","slice","unshift","helper","addHelper","found","getSource","importName","actualSource","isModule","reference","addNamed","importedInterop","importPosition","addNamespace","split","map","location","loc","fileNameIdentifier","filename","generateUidIdentifier","getProgramParent","init","makeTrace","line","column","lineNumber","column0Based","fileLineLiteral","numericLiteral","fileColumnLiteral","template","pluginName"],"sources":["../src/create-plugin.ts"],"sourcesContent":["import jsx from \"@babel/plugin-syntax-jsx\";\nimport { declare } from \"@babel/helper-plugin-utils\";\nimport { template, types as t } from \"@babel/core\";\nimport type { PluginPass } from \"@babel/core\";\nimport type { NodePath, Scope, Visitor } from \"@babel/traverse\";\nimport { addNamed, addNamespace, isModule } from \"@babel/helper-module-imports\";\nimport annotateAsPure from \"@babel/helper-annotate-as-pure\";\nimport type {\n  CallExpression,\n  Class,\n  Expression,\n  Identifier,\n  JSXAttribute,\n  JSXElement,\n  JSXFragment,\n  JSXOpeningElement,\n  JSXSpreadAttribute,\n  MemberExpression,\n  ObjectExpression,\n  Program,\n} from \"@babel/types\";\n\nconst DEFAULT = {\n  importSource: \"react\",\n  runtime: \"automatic\",\n  pragma: \"React.createElement\",\n  pragmaFrag: \"React.Fragment\",\n};\n\nconst JSX_SOURCE_ANNOTATION_REGEX =\n  /^\\s*\\*?\\s*@jsxImportSource\\s+([^\\s]+)\\s*$/m;\nconst JSX_RUNTIME_ANNOTATION_REGEX = /^\\s*\\*?\\s*@jsxRuntime\\s+([^\\s]+)\\s*$/m;\n\nconst JSX_ANNOTATION_REGEX = /^\\s*\\*?\\s*@jsx\\s+([^\\s]+)\\s*$/m;\nconst JSX_FRAG_ANNOTATION_REGEX = /^\\s*\\*?\\s*@jsxFrag\\s+([^\\s]+)\\s*$/m;\n\nconst get = (pass: PluginPass, name: string) =>\n  pass.get(`@babel/plugin-react-jsx/${name}`);\nconst set = (pass: PluginPass, name: string, v: any) =>\n  pass.set(`@babel/plugin-react-jsx/${name}`, v);\n\nfunction hasProto(node: t.ObjectExpression) {\n  return node.properties.some(\n    value =>\n      t.isObjectProperty(value, { computed: false, shorthand: false }) &&\n      (t.isIdentifier(value.key, { name: \"__proto__\" }) ||\n        t.isStringLiteral(value.key, { value: \"__proto__\" })),\n  );\n}\n\nexport interface Options {\n  filter?: (node: t.Node, pass: PluginPass) => boolean;\n  importSource?: string;\n  pragma?: string;\n  pragmaFrag?: string;\n  pure?: string;\n  runtime?: \"automatic\" | \"classic\";\n  throwIfNamespace?: boolean;\n  useBuiltIns: boolean;\n  useSpread?: boolean;\n}\nexport default function createPlugin({\n  name,\n  development,\n}: {\n  name: string;\n  development: boolean;\n}) {\n  return declare((_, options: Options) => {\n    const {\n      pure: PURE_ANNOTATION,\n\n      throwIfNamespace = true,\n\n      // TODO (Babel 8): It should throw if this option is used with the automatic runtime\n      filter,\n\n      runtime: RUNTIME_DEFAULT = process.env.BABEL_8_BREAKING\n        ? \"automatic\"\n        : development\n        ? \"automatic\"\n        : \"classic\",\n\n      importSource: IMPORT_SOURCE_DEFAULT = DEFAULT.importSource,\n      pragma: PRAGMA_DEFAULT = DEFAULT.pragma,\n      pragmaFrag: PRAGMA_FRAG_DEFAULT = DEFAULT.pragmaFrag,\n    } = options;\n\n    if (process.env.BABEL_8_BREAKING) {\n      if (\"useSpread\" in options) {\n        throw new Error(\n          '@babel/plugin-transform-react-jsx: Since Babel 8, an inline object with spread elements is always used, and the \"useSpread\" option is no longer available. Please remove it from your config.',\n        );\n      }\n\n      if (\"useBuiltIns\" in options) {\n        const useBuiltInsFormatted = JSON.stringify(options.useBuiltIns);\n        throw new Error(\n          `@babel/plugin-transform-react-jsx: Since \"useBuiltIns\" is removed in Babel 8, you can remove it from the config.\n- Babel 8 now transforms JSX spread to object spread. If you need to transpile object spread with\n\\`useBuiltIns: ${useBuiltInsFormatted}\\`, you can use the following config\n{\n  \"plugins\": [\n    \"@babel/plugin-transform-react-jsx\"\n    [\"@babel/plugin-proposal-object-rest-spread\", { \"loose\": true, \"useBuiltIns\": ${useBuiltInsFormatted} }]\n  ]\n}`,\n        );\n      }\n    } else {\n      // eslint-disable-next-line no-var\n      var { useSpread = false, useBuiltIns = false } = options;\n\n      if (RUNTIME_DEFAULT === \"classic\") {\n        if (typeof useSpread !== \"boolean\") {\n          throw new Error(\n            \"transform-react-jsx currently only accepts a boolean option for \" +\n              \"useSpread (defaults to false)\",\n          );\n        }\n\n        if (typeof useBuiltIns !== \"boolean\") {\n          throw new Error(\n            \"transform-react-jsx currently only accepts a boolean option for \" +\n              \"useBuiltIns (defaults to false)\",\n          );\n        }\n\n        if (useSpread && useBuiltIns) {\n          throw new Error(\n            \"transform-react-jsx currently only accepts useBuiltIns or useSpread \" +\n              \"but not both\",\n          );\n        }\n      }\n    }\n\n    const injectMetaPropertiesVisitor: Visitor<PluginPass> = {\n      JSXOpeningElement(path, state) {\n        const attributes = [];\n        if (isThisAllowed(path.scope)) {\n          attributes.push(\n            t.jsxAttribute(\n              t.jsxIdentifier(\"__self\"),\n              t.jsxExpressionContainer(t.thisExpression()),\n            ),\n          );\n        }\n        attributes.push(\n          t.jsxAttribute(\n            t.jsxIdentifier(\"__source\"),\n            t.jsxExpressionContainer(makeSource(path, state)),\n          ),\n        );\n        path.pushContainer(\"attributes\", attributes);\n      },\n    };\n\n    return {\n      name,\n      inherits: jsx,\n      visitor: {\n        JSXNamespacedName(path) {\n          if (throwIfNamespace) {\n            throw path.buildCodeFrameError(\n              `Namespace tags are not supported by default. React's JSX doesn't support namespace tags. \\\nYou can set \\`throwIfNamespace: false\\` to bypass this warning.`,\n            );\n          }\n        },\n\n        JSXSpreadChild(path) {\n          throw path.buildCodeFrameError(\n            \"Spread children are not supported in React.\",\n          );\n        },\n\n        Program: {\n          enter(path, state) {\n            const { file } = state;\n            let runtime: string = RUNTIME_DEFAULT;\n\n            let source: string = IMPORT_SOURCE_DEFAULT;\n            let pragma: string = PRAGMA_DEFAULT;\n            let pragmaFrag: string = PRAGMA_FRAG_DEFAULT;\n\n            let sourceSet = !!options.importSource;\n            let pragmaSet = !!options.pragma;\n            let pragmaFragSet = !!options.pragmaFrag;\n\n            if (file.ast.comments) {\n              for (const comment of file.ast.comments) {\n                const sourceMatches = JSX_SOURCE_ANNOTATION_REGEX.exec(\n                  comment.value,\n                );\n                if (sourceMatches) {\n                  source = sourceMatches[1];\n                  sourceSet = true;\n                }\n\n                const runtimeMatches = JSX_RUNTIME_ANNOTATION_REGEX.exec(\n                  comment.value,\n                );\n                if (runtimeMatches) {\n                  runtime = runtimeMatches[1];\n                }\n\n                const jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);\n                if (jsxMatches) {\n                  pragma = jsxMatches[1];\n                  pragmaSet = true;\n                }\n                const jsxFragMatches = JSX_FRAG_ANNOTATION_REGEX.exec(\n                  comment.value,\n                );\n                if (jsxFragMatches) {\n                  pragmaFrag = jsxFragMatches[1];\n                  pragmaFragSet = true;\n                }\n              }\n            }\n\n            set(state, \"runtime\", runtime);\n            if (runtime === \"classic\") {\n              if (sourceSet) {\n                throw path.buildCodeFrameError(\n                  `importSource cannot be set when runtime is classic.`,\n                );\n              }\n\n              const createElement = toMemberExpression(pragma);\n              const fragment = toMemberExpression(pragmaFrag);\n\n              set(state, \"id/createElement\", () => t.cloneNode(createElement));\n              set(state, \"id/fragment\", () => t.cloneNode(fragment));\n\n              set(state, \"defaultPure\", pragma === DEFAULT.pragma);\n            } else if (runtime === \"automatic\") {\n              if (pragmaSet || pragmaFragSet) {\n                throw path.buildCodeFrameError(\n                  `pragma and pragmaFrag cannot be set when runtime is automatic.`,\n                );\n              }\n\n              const define = (name: string, id: string) =>\n                set(state, name, createImportLazily(state, path, id, source));\n\n              define(\"id/jsx\", development ? \"jsxDEV\" : \"jsx\");\n              define(\"id/jsxs\", development ? \"jsxDEV\" : \"jsxs\");\n              define(\"id/createElement\", \"createElement\");\n              define(\"id/fragment\", \"Fragment\");\n\n              set(state, \"defaultPure\", source === DEFAULT.importSource);\n            } else {\n              throw path.buildCodeFrameError(\n                `Runtime must be either \"classic\" or \"automatic\".`,\n              );\n            }\n\n            if (development) {\n              path.traverse(injectMetaPropertiesVisitor, state);\n            }\n          },\n\n          // TODO (Babel 8): Decide if this should be removed or brought back.\n          // see: https://github.com/babel/babel/pull/12253#discussion_r513086528\n          //\n          // exit(path, state) {\n          //   if (\n          //     get(state, \"runtime\") === \"classic\" &&\n          //     get(state, \"pragmaSet\") &&\n          //     get(state, \"usedFragment\") &&\n          //     !get(state, \"pragmaFragSet\")\n          //   ) {\n          //     throw new Error(\n          //       \"transform-react-jsx: pragma has been set but \" +\n          //         \"pragmaFrag has not been set\",\n          //     );\n          //   }\n          // },\n        },\n\n        JSXFragment: {\n          exit(path, file) {\n            let callExpr;\n            if (get(file, \"runtime\") === \"classic\") {\n              callExpr = buildCreateElementFragmentCall(path, file);\n            } else {\n              callExpr = buildJSXFragmentCall(path, file);\n            }\n\n            path.replaceWith(t.inherits(callExpr, path.node));\n          },\n        },\n\n        JSXElement: {\n          exit(path, file) {\n            let callExpr;\n            if (\n              get(file, \"runtime\") === \"classic\" ||\n              shouldUseCreateElement(path)\n            ) {\n              callExpr = buildCreateElementCall(path, file);\n            } else {\n              callExpr = buildJSXElementCall(path, file);\n            }\n\n            path.replaceWith(t.inherits(callExpr, path.node));\n          },\n        },\n\n        JSXAttribute(path) {\n          if (t.isJSXElement(path.node.value)) {\n            path.node.value = t.jsxExpressionContainer(path.node.value);\n          }\n        },\n      },\n    };\n\n    // Returns whether the class has specified a superclass.\n    function isDerivedClass(classPath: NodePath<Class>) {\n      return classPath.node.superClass !== null;\n    }\n\n    // Returns whether `this` is allowed at given scope.\n    function isThisAllowed(scope: Scope) {\n      // This specifically skips arrow functions as they do not rewrite `this`.\n      do {\n        const { path } = scope;\n        if (path.isFunctionParent() && !path.isArrowFunctionExpression()) {\n          if (!path.isMethod()) {\n            // If the closest parent is a regular function, `this` will be rebound, therefore it is fine to use `this`.\n            return true;\n          }\n          // Current node is within a method, so we need to check if the method is a constructor.\n          if (path.node.kind !== \"constructor\") {\n            // We are not in a constructor, therefore it is always fine to use `this`.\n            return true;\n          }\n          // Now we are in a constructor. If it is a derived class, we do not reference `this`.\n          return !isDerivedClass(path.parentPath.parentPath as NodePath<Class>);\n        }\n        if (path.isTSModuleBlock()) {\n          // If the closest parent is a TS Module block, `this` will not be allowed.\n          return false;\n        }\n      } while ((scope = scope.parent));\n      // We are not in a method or function. It is fine to use `this`.\n      return true;\n    }\n\n    function call(\n      pass: PluginPass,\n      name: string,\n      args: CallExpression[\"arguments\"],\n    ) {\n      const node = t.callExpression(get(pass, `id/${name}`)(), args);\n      if (PURE_ANNOTATION ?? get(pass, \"defaultPure\")) annotateAsPure(node);\n      return node;\n    }\n\n    // We want to use React.createElement, even in the case of\n    // jsx, for <div {...props} key={key} /> to distinguish it\n    // from <div key={key} {...props} />. This is an intermediary\n    // step while we deprecate key spread from props. Afterwards,\n    // we will stop using createElement in the transform.\n    function shouldUseCreateElement(path: NodePath<JSXElement>) {\n      const openingPath = path.get(\"openingElement\");\n      const attributes = openingPath.node.attributes;\n\n      let seenPropsSpread = false;\n      for (let i = 0; i < attributes.length; i++) {\n        const attr = attributes[i];\n        if (\n          seenPropsSpread &&\n          t.isJSXAttribute(attr) &&\n          attr.name.name === \"key\"\n        ) {\n          return true;\n        } else if (t.isJSXSpreadAttribute(attr)) {\n          seenPropsSpread = true;\n        }\n      }\n      return false;\n    }\n\n    function convertJSXIdentifier(\n      node: t.JSXIdentifier | t.JSXMemberExpression | t.JSXNamespacedName,\n      parent: t.JSXOpeningElement | t.JSXMemberExpression,\n    ): t.ThisExpression | t.StringLiteral | t.MemberExpression | t.Identifier {\n      if (t.isJSXIdentifier(node)) {\n        if (node.name === \"this\" && t.isReferenced(node, parent)) {\n          return t.thisExpression();\n        } else if (t.isValidIdentifier(node.name, false)) {\n          // @ts-expect-error cast AST type to Identifier\n          node.type = \"Identifier\";\n          return node as unknown as t.Identifier;\n        } else {\n          return t.stringLiteral(node.name);\n        }\n      } else if (t.isJSXMemberExpression(node)) {\n        return t.memberExpression(\n          convertJSXIdentifier(node.object, node),\n          convertJSXIdentifier(node.property, node),\n        );\n      } else if (t.isJSXNamespacedName(node)) {\n        /**\n         * If the flag \"throwIfNamespace\" is false\n         * print XMLNamespace like string literal\n         */\n        return t.stringLiteral(`${node.namespace.name}:${node.name.name}`);\n      }\n\n      // todo: this branch should be unreachable\n      return node;\n    }\n\n    function convertAttributeValue(\n      node: t.JSXAttribute[\"value\"] | t.BooleanLiteral,\n    ) {\n      if (t.isJSXExpressionContainer(node)) {\n        return node.expression;\n      } else {\n        return node;\n      }\n    }\n\n    function accumulateAttribute(\n      array: ObjectExpression[\"properties\"],\n      attribute: NodePath<JSXAttribute | JSXSpreadAttribute>,\n    ) {\n      if (t.isJSXSpreadAttribute(attribute.node)) {\n        const arg = attribute.node.argument;\n        // Collect properties into props array if spreading object expression\n        if (t.isObjectExpression(arg) && !hasProto(arg)) {\n          array.push(...arg.properties);\n        } else {\n          array.push(t.spreadElement(arg));\n        }\n        return array;\n      }\n\n      const value = convertAttributeValue(\n        attribute.node.name.name !== \"key\"\n          ? attribute.node.value || t.booleanLiteral(true)\n          : attribute.node.value,\n      );\n\n      if (attribute.node.name.name === \"key\" && value === null) {\n        throw attribute.buildCodeFrameError(\n          'Please provide an explicit key value. Using \"key\" as a shorthand for \"key={true}\" is not allowed.',\n        );\n      }\n\n      if (\n        t.isStringLiteral(value) &&\n        !t.isJSXExpressionContainer(attribute.node.value)\n      ) {\n        value.value = value.value.replace(/\\n\\s+/g, \" \");\n\n        // \"raw\" JSXText should not be used from a StringLiteral because it needs to be escaped.\n        delete value.extra?.raw;\n      }\n\n      if (t.isJSXNamespacedName(attribute.node.name)) {\n        // @ts-expect-error mutating AST\n        attribute.node.name = t.stringLiteral(\n          attribute.node.name.namespace.name +\n            \":\" +\n            attribute.node.name.name.name,\n        );\n      } else if (t.isValidIdentifier(attribute.node.name.name, false)) {\n        // @ts-expect-error mutating AST\n        attribute.node.name.type = \"Identifier\";\n      } else {\n        // @ts-expect-error mutating AST\n        attribute.node.name = t.stringLiteral(attribute.node.name.name);\n      }\n\n      array.push(\n        t.inherits(\n          t.objectProperty(\n            // @ts-expect-error The attribute.node.name is an Identifier now\n            attribute.node.name,\n            value,\n          ),\n          attribute.node,\n        ),\n      );\n      return array;\n    }\n\n    function buildChildrenProperty(children: Expression[]) {\n      let childrenNode;\n      if (children.length === 1) {\n        childrenNode = children[0];\n      } else if (children.length > 1) {\n        childrenNode = t.arrayExpression(children);\n      } else {\n        return undefined;\n      }\n\n      return t.objectProperty(t.identifier(\"children\"), childrenNode);\n    }\n\n    // Builds JSX into:\n    // Production: React.jsx(type, arguments, key)\n    // Development: React.jsxDEV(type, arguments, key, isStaticChildren, source, self)\n    function buildJSXElementCall(path: NodePath<JSXElement>, file: PluginPass) {\n      const openingPath = path.get(\"openingElement\");\n      const args: t.Expression[] = [getTag(openingPath)];\n\n      const attribsArray = [];\n      const extracted = Object.create(null);\n\n      // for React.jsx, key, __source (dev), and __self (dev) is passed in as\n      // a separate argument rather than in the args object. We go through the\n      // props and filter out these three keywords so we can pass them in\n      // as separate arguments later\n      for (const attr of openingPath.get(\"attributes\")) {\n        if (attr.isJSXAttribute() && t.isJSXIdentifier(attr.node.name)) {\n          const { name } = attr.node.name;\n          switch (name) {\n            case \"__source\":\n            case \"__self\":\n              if (extracted[name]) throw sourceSelfError(path, name);\n            /* falls through */\n            case \"key\": {\n              const keyValue = convertAttributeValue(attr.node.value);\n              if (keyValue === null) {\n                throw attr.buildCodeFrameError(\n                  'Please provide an explicit key value. Using \"key\" as a shorthand for \"key={true}\" is not allowed.',\n                );\n              }\n\n              extracted[name] = keyValue;\n              break;\n            }\n            default:\n              attribsArray.push(attr);\n          }\n        } else {\n          attribsArray.push(attr);\n        }\n      }\n\n      const children = t.react.buildChildren(path.node);\n\n      let attribs: t.ObjectExpression;\n\n      if (attribsArray.length || children.length) {\n        attribs = buildJSXOpeningElementAttributes(\n          attribsArray,\n          //@ts-expect-error The children here contains JSXSpreadChild,\n          // which will be thrown later\n          children,\n        );\n      } else {\n        // attributes should never be null\n        attribs = t.objectExpression([]);\n      }\n\n      args.push(attribs);\n\n      if (development) {\n        // isStaticChildren, __source, and __self are only used in development\n        // automatically include __source and __self in this plugin\n        // so we can eliminate the need for separate Babel plugins in Babel 8\n        args.push(\n          extracted.key ?? path.scope.buildUndefinedNode(),\n          t.booleanLiteral(children.length > 1),\n        );\n        if (extracted.__source) {\n          args.push(extracted.__source);\n          if (extracted.__self) args.push(extracted.__self);\n        } else if (extracted.__self) {\n          args.push(path.scope.buildUndefinedNode(), extracted.__self);\n        }\n      } else if (extracted.key !== undefined) {\n        args.push(extracted.key);\n      }\n\n      return call(file, children.length > 1 ? \"jsxs\" : \"jsx\", args);\n    }\n\n    // Builds props for React.jsx. This function adds children into the props\n    // and ensures that props is always an object\n    function buildJSXOpeningElementAttributes(\n      attribs: NodePath<JSXAttribute | JSXSpreadAttribute>[],\n      children: Expression[],\n    ) {\n      const props = attribs.reduce(accumulateAttribute, []);\n\n      // In React.jsx, children is no longer a separate argument, but passed in\n      // through the argument object\n      if (children?.length > 0) {\n        props.push(buildChildrenProperty(children));\n      }\n\n      return t.objectExpression(props);\n    }\n\n    // Builds JSX Fragment <></> into\n    // Production: React.jsx(type, arguments)\n    // Development: React.jsxDEV(type, { children })\n    function buildJSXFragmentCall(\n      path: NodePath<JSXFragment>,\n      file: PluginPass,\n    ) {\n      const args = [get(file, \"id/fragment\")()];\n\n      const children = t.react.buildChildren(path.node);\n\n      args.push(\n        t.objectExpression(\n          children.length > 0\n            ? [\n                buildChildrenProperty(\n                  //@ts-expect-error The children here contains JSXSpreadChild,\n                  // which will be thrown later\n                  children,\n                ),\n              ]\n            : [],\n        ),\n      );\n\n      if (development) {\n        args.push(\n          path.scope.buildUndefinedNode(),\n          t.booleanLiteral(children.length > 1),\n        );\n      }\n\n      return call(file, children.length > 1 ? \"jsxs\" : \"jsx\", args);\n    }\n\n    // Builds JSX Fragment <></> into\n    // React.createElement(React.Fragment, null, ...children)\n    function buildCreateElementFragmentCall(\n      path: NodePath<JSXFragment>,\n      file: PluginPass,\n    ) {\n      if (filter && !filter(path.node, file)) return;\n\n      return call(file, \"createElement\", [\n        get(file, \"id/fragment\")(),\n        t.nullLiteral(),\n        ...t.react.buildChildren(path.node),\n      ]);\n    }\n\n    // Builds JSX into:\n    // Production: React.createElement(type, arguments, children)\n    // Development: React.createElement(type, arguments, children, source, self)\n    function buildCreateElementCall(\n      path: NodePath<JSXElement>,\n      file: PluginPass,\n    ) {\n      const openingPath = path.get(\"openingElement\");\n\n      return call(file, \"createElement\", [\n        getTag(openingPath),\n        buildCreateElementOpeningElementAttributes(\n          file,\n          path,\n          openingPath.get(\"attributes\"),\n        ),\n        // @ts-expect-error JSXSpreadChild has been transformed in convertAttributeValue\n        ...t.react.buildChildren(path.node),\n      ]);\n    }\n\n    function getTag(openingPath: NodePath<JSXOpeningElement>) {\n      const tagExpr = convertJSXIdentifier(\n        openingPath.node.name,\n        openingPath.node,\n      );\n\n      let tagName: string;\n      if (t.isIdentifier(tagExpr)) {\n        tagName = tagExpr.name;\n      } else if (t.isStringLiteral(tagExpr)) {\n        tagName = tagExpr.value;\n      }\n\n      if (t.react.isCompatTag(tagName)) {\n        return t.stringLiteral(tagName);\n      } else {\n        return tagExpr;\n      }\n    }\n\n    /**\n     * The logic for this is quite terse. It's because we need to\n     * support spread elements. We loop over all attributes,\n     * breaking on spreads, we then push a new object containing\n     * all prior attributes to an array for later processing.\n     */\n    function buildCreateElementOpeningElementAttributes(\n      file: PluginPass,\n      path: NodePath<JSXElement>,\n      attribs: NodePath<JSXAttribute | JSXSpreadAttribute>[],\n    ) {\n      const runtime = get(file, \"runtime\");\n      if (!process.env.BABEL_8_BREAKING) {\n        if (runtime !== \"automatic\") {\n          const objs = [];\n          const props = attribs.reduce(accumulateAttribute, []);\n\n          if (!useSpread) {\n            // Convert syntax to use multiple objects instead of spread\n            let start = 0;\n            props.forEach((prop, i) => {\n              if (t.isSpreadElement(prop)) {\n                if (i > start) {\n                  objs.push(t.objectExpression(props.slice(start, i)));\n                }\n                objs.push(prop.argument);\n                start = i + 1;\n              }\n            });\n            if (props.length > start) {\n              objs.push(t.objectExpression(props.slice(start)));\n            }\n          } else if (props.length) {\n            objs.push(t.objectExpression(props));\n          }\n\n          if (!objs.length) {\n            return t.nullLiteral();\n          }\n\n          if (objs.length === 1) {\n            if (\n              !(\n                t.isSpreadElement(props[0]) &&\n                // If an object expression is spread element's argument\n                // it is very likely to contain __proto__ and we should stop\n                // optimizing spread element\n                t.isObjectExpression(props[0].argument)\n              )\n            ) {\n              return objs[0];\n            }\n          }\n\n          // looks like we have multiple objects\n          if (!t.isObjectExpression(objs[0])) {\n            objs.unshift(t.objectExpression([]));\n          }\n\n          const helper = useBuiltIns\n            ? t.memberExpression(t.identifier(\"Object\"), t.identifier(\"assign\"))\n            : file.addHelper(\"extends\");\n\n          // spread it\n          return t.callExpression(helper, objs);\n        }\n      }\n\n      const props: ObjectExpression[\"properties\"] = [];\n      const found = Object.create(null);\n\n      for (const attr of attribs) {\n        const name =\n          t.isJSXAttribute(attr) &&\n          t.isJSXIdentifier(attr.name) &&\n          attr.name.name;\n\n        if (\n          runtime === \"automatic\" &&\n          (name === \"__source\" || name === \"__self\")\n        ) {\n          if (found[name]) throw sourceSelfError(path, name);\n          found[name] = true;\n        }\n\n        accumulateAttribute(props, attr);\n      }\n\n      return props.length === 1 &&\n        t.isSpreadElement(props[0]) &&\n        // If an object expression is spread element's argument\n        // it is very likely to contain __proto__ and we should stop\n        // optimizing spread element\n        !t.isObjectExpression(props[0].argument)\n        ? props[0].argument\n        : props.length > 0\n        ? t.objectExpression(props)\n        : t.nullLiteral();\n    }\n  });\n\n  function getSource(source: string, importName: string) {\n    switch (importName) {\n      case \"Fragment\":\n        return `${source}/${development ? \"jsx-dev-runtime\" : \"jsx-runtime\"}`;\n      case \"jsxDEV\":\n        return `${source}/jsx-dev-runtime`;\n      case \"jsx\":\n      case \"jsxs\":\n        return `${source}/jsx-runtime`;\n      case \"createElement\":\n        return source;\n    }\n  }\n\n  function createImportLazily(\n    pass: PluginPass,\n    path: NodePath<Program>,\n    importName: string,\n    source: string,\n  ): () => Identifier | MemberExpression {\n    return () => {\n      const actualSource = getSource(source, importName);\n      if (isModule(path)) {\n        let reference = get(pass, `imports/${importName}`);\n        if (reference) return t.cloneNode(reference);\n\n        reference = addNamed(path, importName, actualSource, {\n          importedInterop: \"uncompiled\",\n          importPosition: \"after\",\n        });\n        set(pass, `imports/${importName}`, reference);\n\n        return reference;\n      } else {\n        let reference = get(pass, `requires/${actualSource}`);\n        if (reference) {\n          reference = t.cloneNode(reference);\n        } else {\n          reference = addNamespace(path, actualSource, {\n            importedInterop: \"uncompiled\",\n          });\n          set(pass, `requires/${actualSource}`, reference);\n        }\n\n        return t.memberExpression(reference, t.identifier(importName));\n      }\n    };\n  }\n}\n\nfunction toMemberExpression(id: string): Identifier | MemberExpression {\n  return (\n    id\n      .split(\".\")\n      .map(name => t.identifier(name))\n      // @ts-expect-error - The Array#reduce does not have a signature\n      // where the type of initial value differs from callback return type\n      .reduce((object, property) => t.memberExpression(object, property))\n  );\n}\n\nfunction makeSource(path: NodePath, state: PluginPass) {\n  const location = path.node.loc;\n  if (!location) {\n    // the element was generated and doesn't have location information\n    return path.scope.buildUndefinedNode();\n  }\n\n  // @ts-expect-error todo: avoid mutating PluginPass\n  if (!state.fileNameIdentifier) {\n    const { filename = \"\" } = state;\n\n    const fileNameIdentifier = path.scope.generateUidIdentifier(\"_jsxFileName\");\n    path.scope.getProgramParent().push({\n      id: fileNameIdentifier,\n      init: t.stringLiteral(filename),\n    });\n    // @ts-expect-error todo: avoid mutating PluginPass\n    state.fileNameIdentifier = fileNameIdentifier;\n  }\n\n  return makeTrace(\n    t.cloneNode(\n      // @ts-expect-error todo: avoid mutating PluginPass\n      state.fileNameIdentifier,\n    ),\n    location.start.line,\n    location.start.column,\n  );\n}\n\nfunction makeTrace(\n  fileNameIdentifier: Identifier,\n  lineNumber?: number,\n  column0Based?: number,\n) {\n  const fileLineLiteral =\n    lineNumber != null ? t.numericLiteral(lineNumber) : t.nullLiteral();\n\n  const fileColumnLiteral =\n    column0Based != null ? t.numericLiteral(column0Based + 1) : t.nullLiteral();\n\n  return template.expression.ast`{\n    fileName: ${fileNameIdentifier},\n    lineNumber: ${fileLineLiteral},\n    columnNumber: ${fileColumnLiteral},\n  }`;\n}\n\nfunction sourceSelfError(path: NodePath, name: string) {\n  const pluginName = `transform-react-jsx-${name.slice(2)}`;\n\n  return path.buildCodeFrameError(\n    `Duplicate ${name} prop found. You are most likely using the deprecated ${pluginName} Babel plugin. Both __source and __self are automatically set when using the automatic runtime. Please remove transform-react-jsx-source and transform-react-jsx-self from your Babel config.`,\n  );\n}\n"],"mappings":"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"}
=======
<<<<<<< HEAD
{"version":3,"names":["DEFAULT","importSource","runtime","pragma","pragmaFrag","JSX_SOURCE_ANNOTATION_REGEX","JSX_RUNTIME_ANNOTATION_REGEX","JSX_ANNOTATION_REGEX","JSX_FRAG_ANNOTATION_REGEX","get","pass","name","set","v","hasProto","node","properties","some","value","t","isObjectProperty","computed","shorthand","isIdentifier","key","isStringLiteral","createPlugin","development","declare","_","options","pure","PURE_ANNOTATION","throwIfNamespace","filter","RUNTIME_DEFAULT","IMPORT_SOURCE_DEFAULT","PRAGMA_DEFAULT","PRAGMA_FRAG_DEFAULT","useSpread","useBuiltIns","Error","injectMetaPropertiesVisitor","JSXOpeningElement","path","state","attributes","isThisAllowed","scope","push","jsxAttribute","jsxIdentifier","jsxExpressionContainer","thisExpression","makeSource","pushContainer","inherits","jsx","visitor","JSXNamespacedName","buildCodeFrameError","JSXSpreadChild","Program","enter","file","source","sourceSet","pragmaSet","pragmaFragSet","ast","comments","comment","sourceMatches","exec","runtimeMatches","jsxMatches","jsxFragMatches","createElement","toMemberExpression","fragment","cloneNode","define","id","createImportLazily","traverse","JSXElement","exit","callExpr","shouldUseCreateElement","buildCreateElementCall","buildJSXElementCall","replaceWith","JSXFragment","buildCreateElementFragmentCall","buildJSXFragmentCall","JSXAttribute","isJSXElement","isDerivedClass","classPath","superClass","isFunctionParent","isArrowFunctionExpression","isMethod","kind","parentPath","isTSModuleBlock","parent","call","args","callExpression","annotateAsPure","openingPath","seenPropsSpread","i","length","attr","isJSXAttribute","isJSXSpreadAttribute","convertJSXIdentifier","isJSXIdentifier","isReferenced","isValidIdentifier","type","stringLiteral","isJSXMemberExpression","memberExpression","object","property","isJSXNamespacedName","namespace","convertAttributeValue","isJSXExpressionContainer","expression","accumulateAttribute","array","attribute","arg","argument","isObjectExpression","spreadElement","booleanLiteral","replace","extra","raw","objectProperty","buildChildrenProperty","children","childrenNode","arrayExpression","undefined","identifier","getTag","attribsArray","extracted","Object","create","sourceSelfError","keyValue","react","buildChildren","attribs","buildJSXOpeningElementAttributes","objectExpression","buildUndefinedNode","__source","__self","props","reduce","nullLiteral","buildCreateElementOpeningElementAttributes","tagExpr","tagName","isCompatTag","objs","start","forEach","prop","isSpreadElement","slice","unshift","helper","addHelper","found","getSource","importName","actualSource","isModule","reference","addNamed","importedInterop","importPosition","addNamespace","split","map","location","loc","fileNameIdentifier","filename","generateUidIdentifier","hub","getScope","init","makeTrace","line","column","lineNumber","column0Based","fileLineLiteral","numericLiteral","fileColumnLiteral","fileNameProperty","lineNumberProperty","columnNumberProperty","pluginName"],"sources":["../src/create-plugin.ts"],"sourcesContent":["import jsx from \"@babel/plugin-syntax-jsx\";\nimport { declare } from \"@babel/helper-plugin-utils\";\nimport { types as t } from \"@babel/core\";\nimport type { PluginPass } from \"@babel/core\";\nimport type { NodePath, Scope, Visitor } from \"@babel/traverse\";\nimport { addNamed, addNamespace, isModule } from \"@babel/helper-module-imports\";\nimport annotateAsPure from \"@babel/helper-annotate-as-pure\";\nimport type {\n  CallExpression,\n  Class,\n  Expression,\n  Identifier,\n  JSXAttribute,\n  JSXElement,\n  JSXFragment,\n  JSXOpeningElement,\n  JSXSpreadAttribute,\n  MemberExpression,\n  ObjectExpression,\n  Program,\n} from \"@babel/types\";\n\nconst DEFAULT = {\n  importSource: \"react\",\n  runtime: \"automatic\",\n  pragma: \"React.createElement\",\n  pragmaFrag: \"React.Fragment\",\n};\n\nconst JSX_SOURCE_ANNOTATION_REGEX =\n  /^\\s*\\*?\\s*@jsxImportSource\\s+([^\\s]+)\\s*$/m;\nconst JSX_RUNTIME_ANNOTATION_REGEX = /^\\s*\\*?\\s*@jsxRuntime\\s+([^\\s]+)\\s*$/m;\n\nconst JSX_ANNOTATION_REGEX = /^\\s*\\*?\\s*@jsx\\s+([^\\s]+)\\s*$/m;\nconst JSX_FRAG_ANNOTATION_REGEX = /^\\s*\\*?\\s*@jsxFrag\\s+([^\\s]+)\\s*$/m;\n\nconst get = (pass: PluginPass, name: string) =>\n  pass.get(`@babel/plugin-react-jsx/${name}`);\nconst set = (pass: PluginPass, name: string, v: any) =>\n  pass.set(`@babel/plugin-react-jsx/${name}`, v);\n\nfunction hasProto(node: t.ObjectExpression) {\n  return node.properties.some(\n    value =>\n      t.isObjectProperty(value, { computed: false, shorthand: false }) &&\n      (t.isIdentifier(value.key, { name: \"__proto__\" }) ||\n        t.isStringLiteral(value.key, { value: \"__proto__\" })),\n  );\n}\n\nexport interface Options {\n  filter?: (node: t.Node, pass: PluginPass) => boolean;\n  importSource?: string;\n  pragma?: string;\n  pragmaFrag?: string;\n  pure?: string;\n  runtime?: \"automatic\" | \"classic\";\n  throwIfNamespace?: boolean;\n  useBuiltIns: boolean;\n  useSpread?: boolean;\n}\nexport default function createPlugin({\n  name,\n  development,\n}: {\n  name: string;\n  development: boolean;\n}) {\n  return declare((_, options: Options) => {\n    const {\n      pure: PURE_ANNOTATION,\n\n      throwIfNamespace = true,\n\n      // TODO (Babel 8): It should throw if this option is used with the automatic runtime\n      filter,\n\n      runtime: RUNTIME_DEFAULT = process.env.BABEL_8_BREAKING\n        ? \"automatic\"\n        : development\n        ? \"automatic\"\n        : \"classic\",\n\n      importSource: IMPORT_SOURCE_DEFAULT = DEFAULT.importSource,\n      pragma: PRAGMA_DEFAULT = DEFAULT.pragma,\n      pragmaFrag: PRAGMA_FRAG_DEFAULT = DEFAULT.pragmaFrag,\n    } = options;\n\n    if (process.env.BABEL_8_BREAKING) {\n      if (\"useSpread\" in options) {\n        throw new Error(\n          '@babel/plugin-transform-react-jsx: Since Babel 8, an inline object with spread elements is always used, and the \"useSpread\" option is no longer available. Please remove it from your config.',\n        );\n      }\n\n      if (\"useBuiltIns\" in options) {\n        const useBuiltInsFormatted = JSON.stringify(options.useBuiltIns);\n        throw new Error(\n          `@babel/plugin-transform-react-jsx: Since \"useBuiltIns\" is removed in Babel 8, you can remove it from the config.\n- Babel 8 now transforms JSX spread to object spread. If you need to transpile object spread with\n\\`useBuiltIns: ${useBuiltInsFormatted}\\`, you can use the following config\n{\n  \"plugins\": [\n    \"@babel/plugin-transform-react-jsx\"\n    [\"@babel/plugin-proposal-object-rest-spread\", { \"loose\": true, \"useBuiltIns\": ${useBuiltInsFormatted} }]\n  ]\n}`,\n        );\n      }\n    } else {\n      // eslint-disable-next-line no-var\n      var { useSpread = false, useBuiltIns = false } = options;\n\n      if (RUNTIME_DEFAULT === \"classic\") {\n        if (typeof useSpread !== \"boolean\") {\n          throw new Error(\n            \"transform-react-jsx currently only accepts a boolean option for \" +\n              \"useSpread (defaults to false)\",\n          );\n        }\n\n        if (typeof useBuiltIns !== \"boolean\") {\n          throw new Error(\n            \"transform-react-jsx currently only accepts a boolean option for \" +\n              \"useBuiltIns (defaults to false)\",\n          );\n        }\n\n        if (useSpread && useBuiltIns) {\n          throw new Error(\n            \"transform-react-jsx currently only accepts useBuiltIns or useSpread \" +\n              \"but not both\",\n          );\n        }\n      }\n    }\n\n    const injectMetaPropertiesVisitor: Visitor<PluginPass> = {\n      JSXOpeningElement(path, state) {\n        const attributes = [];\n        if (isThisAllowed(path.scope)) {\n          attributes.push(\n            t.jsxAttribute(\n              t.jsxIdentifier(\"__self\"),\n              t.jsxExpressionContainer(t.thisExpression()),\n            ),\n          );\n        }\n        attributes.push(\n          t.jsxAttribute(\n            t.jsxIdentifier(\"__source\"),\n            t.jsxExpressionContainer(makeSource(path, state)),\n          ),\n        );\n        path.pushContainer(\"attributes\", attributes);\n      },\n    };\n\n    return {\n      name,\n      inherits: jsx,\n      visitor: {\n        JSXNamespacedName(path) {\n          if (throwIfNamespace) {\n            throw path.buildCodeFrameError(\n              `Namespace tags are not supported by default. React's JSX doesn't support namespace tags. \\\nYou can set \\`throwIfNamespace: false\\` to bypass this warning.`,\n            );\n          }\n        },\n\n        JSXSpreadChild(path) {\n          throw path.buildCodeFrameError(\n            \"Spread children are not supported in React.\",\n          );\n        },\n\n        Program: {\n          enter(path, state) {\n            const { file } = state;\n            let runtime: string = RUNTIME_DEFAULT;\n\n            let source: string = IMPORT_SOURCE_DEFAULT;\n            let pragma: string = PRAGMA_DEFAULT;\n            let pragmaFrag: string = PRAGMA_FRAG_DEFAULT;\n\n            let sourceSet = !!options.importSource;\n            let pragmaSet = !!options.pragma;\n            let pragmaFragSet = !!options.pragmaFrag;\n\n            if (file.ast.comments) {\n              for (const comment of file.ast.comments) {\n                const sourceMatches = JSX_SOURCE_ANNOTATION_REGEX.exec(\n                  comment.value,\n                );\n                if (sourceMatches) {\n                  source = sourceMatches[1];\n                  sourceSet = true;\n                }\n\n                const runtimeMatches = JSX_RUNTIME_ANNOTATION_REGEX.exec(\n                  comment.value,\n                );\n                if (runtimeMatches) {\n                  runtime = runtimeMatches[1];\n                }\n\n                const jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);\n                if (jsxMatches) {\n                  pragma = jsxMatches[1];\n                  pragmaSet = true;\n                }\n                const jsxFragMatches = JSX_FRAG_ANNOTATION_REGEX.exec(\n                  comment.value,\n                );\n                if (jsxFragMatches) {\n                  pragmaFrag = jsxFragMatches[1];\n                  pragmaFragSet = true;\n                }\n              }\n            }\n\n            set(state, \"runtime\", runtime);\n            if (runtime === \"classic\") {\n              if (sourceSet) {\n                throw path.buildCodeFrameError(\n                  `importSource cannot be set when runtime is classic.`,\n                );\n              }\n\n              const createElement = toMemberExpression(pragma);\n              const fragment = toMemberExpression(pragmaFrag);\n\n              set(state, \"id/createElement\", () => t.cloneNode(createElement));\n              set(state, \"id/fragment\", () => t.cloneNode(fragment));\n\n              set(state, \"defaultPure\", pragma === DEFAULT.pragma);\n            } else if (runtime === \"automatic\") {\n              if (pragmaSet || pragmaFragSet) {\n                throw path.buildCodeFrameError(\n                  `pragma and pragmaFrag cannot be set when runtime is automatic.`,\n                );\n              }\n\n              const define = (name: string, id: string) =>\n                set(state, name, createImportLazily(state, path, id, source));\n\n              define(\"id/jsx\", development ? \"jsxDEV\" : \"jsx\");\n              define(\"id/jsxs\", development ? \"jsxDEV\" : \"jsxs\");\n              define(\"id/createElement\", \"createElement\");\n              define(\"id/fragment\", \"Fragment\");\n\n              set(state, \"defaultPure\", source === DEFAULT.importSource);\n            } else {\n              throw path.buildCodeFrameError(\n                `Runtime must be either \"classic\" or \"automatic\".`,\n              );\n            }\n\n            if (development) {\n              path.traverse(injectMetaPropertiesVisitor, state);\n            }\n          },\n\n          // TODO (Babel 8): Decide if this should be removed or brought back.\n          // see: https://github.com/babel/babel/pull/12253#discussion_r513086528\n          //\n          // exit(path, state) {\n          //   if (\n          //     get(state, \"runtime\") === \"classic\" &&\n          //     get(state, \"pragmaSet\") &&\n          //     get(state, \"usedFragment\") &&\n          //     !get(state, \"pragmaFragSet\")\n          //   ) {\n          //     throw new Error(\n          //       \"transform-react-jsx: pragma has been set but \" +\n          //         \"pragmaFrag has not been set\",\n          //     );\n          //   }\n          // },\n        },\n\n        JSXElement: {\n          exit(path, file) {\n            let callExpr;\n            if (\n              get(file, \"runtime\") === \"classic\" ||\n              shouldUseCreateElement(path)\n            ) {\n              callExpr = buildCreateElementCall(path, file);\n            } else {\n              callExpr = buildJSXElementCall(path, file);\n            }\n\n            path.replaceWith(t.inherits(callExpr, path.node));\n          },\n        },\n\n        JSXFragment: {\n          exit(path, file) {\n            let callExpr;\n            if (get(file, \"runtime\") === \"classic\") {\n              callExpr = buildCreateElementFragmentCall(path, file);\n            } else {\n              callExpr = buildJSXFragmentCall(path, file);\n            }\n\n            path.replaceWith(t.inherits(callExpr, path.node));\n          },\n        },\n\n        JSXAttribute(path) {\n          if (t.isJSXElement(path.node.value)) {\n            path.node.value = t.jsxExpressionContainer(path.node.value);\n          }\n        },\n      } as Visitor<PluginPass>,\n    };\n\n    // Returns whether the class has specified a superclass.\n    function isDerivedClass(classPath: NodePath<Class>) {\n      return classPath.node.superClass !== null;\n    }\n\n    // Returns whether `this` is allowed at given scope.\n    function isThisAllowed(scope: Scope) {\n      // This specifically skips arrow functions as they do not rewrite `this`.\n      do {\n        const { path } = scope;\n        if (path.isFunctionParent() && !path.isArrowFunctionExpression()) {\n          if (!path.isMethod()) {\n            // If the closest parent is a regular function, `this` will be rebound, therefore it is fine to use `this`.\n            return true;\n          }\n          // Current node is within a method, so we need to check if the method is a constructor.\n          if (path.node.kind !== \"constructor\") {\n            // We are not in a constructor, therefore it is always fine to use `this`.\n            return true;\n          }\n          // Now we are in a constructor. If it is a derived class, we do not reference `this`.\n          return !isDerivedClass(path.parentPath.parentPath as NodePath<Class>);\n        }\n        if (path.isTSModuleBlock()) {\n          // If the closeset parent is a TS Module block, `this` will not be allowed.\n          return false;\n        }\n      } while ((scope = scope.parent));\n      // We are not in a method or function. It is fine to use `this`.\n      return true;\n    }\n\n    function call(\n      pass: PluginPass,\n      name: string,\n      args: CallExpression[\"arguments\"],\n    ) {\n      const node = t.callExpression(get(pass, `id/${name}`)(), args);\n      if (PURE_ANNOTATION ?? get(pass, \"defaultPure\")) annotateAsPure(node);\n      return node;\n    }\n\n    // We want to use React.createElement, even in the case of\n    // jsx, for <div {...props} key={key} /> to distinguish it\n    // from <div key={key} {...props} />. This is an intermediary\n    // step while we deprecate key spread from props. Afterwards,\n    // we will stop using createElement in the transform.\n    function shouldUseCreateElement(path: NodePath<JSXElement>) {\n      const openingPath = path.get(\"openingElement\");\n      const attributes = openingPath.node.attributes;\n\n      let seenPropsSpread = false;\n      for (let i = 0; i < attributes.length; i++) {\n        const attr = attributes[i];\n        if (\n          seenPropsSpread &&\n          t.isJSXAttribute(attr) &&\n          attr.name.name === \"key\"\n        ) {\n          return true;\n        } else if (t.isJSXSpreadAttribute(attr)) {\n          seenPropsSpread = true;\n        }\n      }\n      return false;\n    }\n\n    function convertJSXIdentifier(\n      node: t.JSXIdentifier | t.JSXMemberExpression | t.JSXNamespacedName,\n      parent: t.JSXOpeningElement | t.JSXMemberExpression,\n    ): t.ThisExpression | t.StringLiteral | t.MemberExpression | t.Identifier {\n      if (t.isJSXIdentifier(node)) {\n        if (node.name === \"this\" && t.isReferenced(node, parent)) {\n          return t.thisExpression();\n        } else if (t.isValidIdentifier(node.name, false)) {\n          // @ts-expect-error cast AST type to Identifier\n          node.type = \"Identifier\";\n          return node as unknown as t.Identifier;\n        } else {\n          return t.stringLiteral(node.name);\n        }\n      } else if (t.isJSXMemberExpression(node)) {\n        return t.memberExpression(\n          convertJSXIdentifier(node.object, node),\n          convertJSXIdentifier(node.property, node),\n        );\n      } else if (t.isJSXNamespacedName(node)) {\n        /**\n         * If the flag \"throwIfNamespace\" is false\n         * print XMLNamespace like string literal\n         */\n        return t.stringLiteral(`${node.namespace.name}:${node.name.name}`);\n      }\n\n      // todo: this branch should be unreachable\n      return node;\n    }\n\n    function convertAttributeValue(\n      node: t.JSXAttribute[\"value\"] | t.BooleanLiteral,\n    ) {\n      if (t.isJSXExpressionContainer(node)) {\n        return node.expression;\n      } else {\n        return node;\n      }\n    }\n\n    function accumulateAttribute(\n      array: ObjectExpression[\"properties\"],\n      attribute: NodePath<JSXAttribute | JSXSpreadAttribute>,\n    ) {\n      if (t.isJSXSpreadAttribute(attribute.node)) {\n        const arg = attribute.node.argument;\n        // Collect properties into props array if spreading object expression\n        if (t.isObjectExpression(arg) && !hasProto(arg)) {\n          array.push(...arg.properties);\n        } else {\n          array.push(t.spreadElement(arg));\n        }\n        return array;\n      }\n\n      const value = convertAttributeValue(\n        attribute.node.name.name !== \"key\"\n          ? attribute.node.value || t.booleanLiteral(true)\n          : attribute.node.value,\n      );\n\n      if (attribute.node.name.name === \"key\" && value === null) {\n        throw attribute.buildCodeFrameError(\n          'Please provide an explicit key value. Using \"key\" as a shorthand for \"key={true}\" is not allowed.',\n        );\n      }\n\n      if (\n        t.isStringLiteral(value) &&\n        !t.isJSXExpressionContainer(attribute.node.value)\n      ) {\n        value.value = value.value.replace(/\\n\\s+/g, \" \");\n\n        // \"raw\" JSXText should not be used from a StringLiteral because it needs to be escaped.\n        delete value.extra?.raw;\n      }\n\n      if (t.isJSXNamespacedName(attribute.node.name)) {\n        // @ts-expect-error mutating AST\n        attribute.node.name = t.stringLiteral(\n          attribute.node.name.namespace.name +\n            \":\" +\n            attribute.node.name.name.name,\n        );\n      } else if (t.isValidIdentifier(attribute.node.name.name, false)) {\n        // @ts-expect-error mutating AST\n        attribute.node.name.type = \"Identifier\";\n      } else {\n        // @ts-expect-error mutating AST\n        attribute.node.name = t.stringLiteral(attribute.node.name.name);\n      }\n\n      array.push(\n        t.inherits(\n          t.objectProperty(\n            // @ts-expect-error The attribute.node.name is an Identifier now\n            attribute.node.name,\n            value,\n          ),\n          attribute.node,\n        ),\n      );\n      return array;\n    }\n\n    function buildChildrenProperty(children: Expression[]) {\n      let childrenNode;\n      if (children.length === 1) {\n        childrenNode = children[0];\n      } else if (children.length > 1) {\n        childrenNode = t.arrayExpression(children);\n      } else {\n        return undefined;\n      }\n\n      return t.objectProperty(t.identifier(\"children\"), childrenNode);\n    }\n\n    // Builds JSX into:\n    // Production: React.jsx(type, arguments, key)\n    // Development: React.jsxDEV(type, arguments, key, isStaticChildren, source, self)\n    function buildJSXElementCall(path: NodePath<JSXElement>, file: PluginPass) {\n      const openingPath = path.get(\"openingElement\");\n      const args: t.Expression[] = [getTag(openingPath)];\n\n      const attribsArray = [];\n      const extracted = Object.create(null);\n\n      // for React.jsx, key, __source (dev), and __self (dev) is passed in as\n      // a separate argument rather than in the args object. We go through the\n      // props and filter out these three keywords so we can pass them in\n      // as separate arguments later\n      for (const attr of openingPath.get(\"attributes\")) {\n        if (attr.isJSXAttribute() && t.isJSXIdentifier(attr.node.name)) {\n          const { name } = attr.node.name;\n          switch (name) {\n            case \"__source\":\n            case \"__self\":\n              if (extracted[name]) throw sourceSelfError(path, name);\n            /* falls through */\n            case \"key\": {\n              const keyValue = convertAttributeValue(attr.node.value);\n              if (keyValue === null) {\n                throw attr.buildCodeFrameError(\n                  'Please provide an explicit key value. Using \"key\" as a shorthand for \"key={true}\" is not allowed.',\n                );\n              }\n\n              extracted[name] = keyValue;\n              break;\n            }\n            default:\n              attribsArray.push(attr);\n          }\n        } else {\n          attribsArray.push(attr);\n        }\n      }\n\n      const children = t.react.buildChildren(path.node);\n\n      let attribs: t.ObjectExpression;\n\n      if (attribsArray.length || children.length) {\n        attribs = buildJSXOpeningElementAttributes(\n          attribsArray,\n          //@ts-expect-error The children here contains JSXSpreadChild,\n          // which will be thrown later\n          children,\n        );\n      } else {\n        // attributes should never be null\n        attribs = t.objectExpression([]);\n      }\n\n      args.push(attribs);\n\n      if (development) {\n        // isStaticChildren, __source, and __self are only used in development\n        // automatically include __source and __self in this plugin\n        // so we can eliminate the need for separate Babel plugins in Babel 8\n        args.push(\n          extracted.key ?? path.scope.buildUndefinedNode(),\n          t.booleanLiteral(children.length > 1),\n          extracted.__source ?? path.scope.buildUndefinedNode(),\n          extracted.__self ?? path.scope.buildUndefinedNode(),\n        );\n      } else if (extracted.key !== undefined) {\n        args.push(extracted.key);\n      }\n\n      return call(file, children.length > 1 ? \"jsxs\" : \"jsx\", args);\n    }\n\n    // Builds props for React.jsx. This function adds children into the props\n    // and ensures that props is always an object\n    function buildJSXOpeningElementAttributes(\n      attribs: NodePath<JSXAttribute | JSXSpreadAttribute>[],\n      children: Expression[],\n    ) {\n      const props = attribs.reduce(accumulateAttribute, []);\n\n      // In React.jsx, children is no longer a separate argument, but passed in\n      // through the argument object\n      if (children?.length > 0) {\n        props.push(buildChildrenProperty(children));\n      }\n\n      return t.objectExpression(props);\n    }\n\n    // Builds JSX Fragment <></> into\n    // Production: React.jsx(type, arguments)\n    // Development: React.jsxDEV(type, { children })\n    function buildJSXFragmentCall(\n      path: NodePath<JSXFragment>,\n      file: PluginPass,\n    ) {\n      const args = [get(file, \"id/fragment\")()];\n\n      const children = t.react.buildChildren(path.node);\n\n      args.push(\n        t.objectExpression(\n          children.length > 0\n            ? [\n                buildChildrenProperty(\n                  //@ts-expect-error The children here contains JSXSpreadChild,\n                  // which will be thrown later\n                  children,\n                ),\n              ]\n            : [],\n        ),\n      );\n\n      if (development) {\n        args.push(\n          path.scope.buildUndefinedNode(),\n          t.booleanLiteral(children.length > 1),\n        );\n      }\n\n      return call(file, children.length > 1 ? \"jsxs\" : \"jsx\", args);\n    }\n\n    // Builds JSX Fragment <></> into\n    // React.createElement(React.Fragment, null, ...children)\n    function buildCreateElementFragmentCall(\n      path: NodePath<JSXFragment>,\n      file: PluginPass,\n    ) {\n      if (filter && !filter(path.node, file)) return;\n\n      return call(file, \"createElement\", [\n        get(file, \"id/fragment\")(),\n        t.nullLiteral(),\n        ...t.react.buildChildren(path.node),\n      ]);\n    }\n\n    // Builds JSX into:\n    // Production: React.createElement(type, arguments, children)\n    // Development: React.createElement(type, arguments, children, source, self)\n    function buildCreateElementCall(\n      path: NodePath<JSXElement>,\n      file: PluginPass,\n    ) {\n      const openingPath = path.get(\"openingElement\");\n\n      return call(file, \"createElement\", [\n        getTag(openingPath),\n        buildCreateElementOpeningElementAttributes(\n          file,\n          path,\n          openingPath.get(\"attributes\"),\n        ),\n        // @ts-expect-error JSXSpreadChild has been transformed in convertAttributeValue\n        ...t.react.buildChildren(path.node),\n      ]);\n    }\n\n    function getTag(openingPath: NodePath<JSXOpeningElement>) {\n      const tagExpr = convertJSXIdentifier(\n        openingPath.node.name,\n        openingPath.node,\n      );\n\n      let tagName: string;\n      if (t.isIdentifier(tagExpr)) {\n        tagName = tagExpr.name;\n      } else if (t.isStringLiteral(tagExpr)) {\n        tagName = tagExpr.value;\n      }\n\n      if (t.react.isCompatTag(tagName)) {\n        return t.stringLiteral(tagName);\n      } else {\n        return tagExpr;\n      }\n    }\n\n    /**\n     * The logic for this is quite terse. It's because we need to\n     * support spread elements. We loop over all attributes,\n     * breaking on spreads, we then push a new object containing\n     * all prior attributes to an array for later processing.\n     */\n    function buildCreateElementOpeningElementAttributes(\n      file: PluginPass,\n      path: NodePath<JSXElement>,\n      attribs: NodePath<JSXAttribute | JSXSpreadAttribute>[],\n    ) {\n      const runtime = get(file, \"runtime\");\n      if (!process.env.BABEL_8_BREAKING) {\n        if (runtime !== \"automatic\") {\n          const objs = [];\n          const props = attribs.reduce(accumulateAttribute, []);\n\n          if (!useSpread) {\n            // Convert syntax to use multiple objects instead of spread\n            let start = 0;\n            props.forEach((prop, i) => {\n              if (t.isSpreadElement(prop)) {\n                if (i > start) {\n                  objs.push(t.objectExpression(props.slice(start, i)));\n                }\n                objs.push(prop.argument);\n                start = i + 1;\n              }\n            });\n            if (props.length > start) {\n              objs.push(t.objectExpression(props.slice(start)));\n            }\n          } else if (props.length) {\n            objs.push(t.objectExpression(props));\n          }\n\n          if (!objs.length) {\n            return t.nullLiteral();\n          }\n\n          if (objs.length === 1) {\n            if (\n              !(\n                t.isSpreadElement(props[0]) &&\n                // If an object expression is spread element's argument\n                // it is very likely to contain __proto__ and we should stop\n                // optimizing spread element\n                t.isObjectExpression(props[0].argument)\n              )\n            ) {\n              return objs[0];\n            }\n          }\n\n          // looks like we have multiple objects\n          if (!t.isObjectExpression(objs[0])) {\n            objs.unshift(t.objectExpression([]));\n          }\n\n          const helper = useBuiltIns\n            ? t.memberExpression(t.identifier(\"Object\"), t.identifier(\"assign\"))\n            : file.addHelper(\"extends\");\n\n          // spread it\n          return t.callExpression(helper, objs);\n        }\n      }\n\n      const props: ObjectExpression[\"properties\"] = [];\n      const found = Object.create(null);\n\n      for (const attr of attribs) {\n        const name =\n          t.isJSXAttribute(attr) &&\n          t.isJSXIdentifier(attr.name) &&\n          attr.name.name;\n\n        if (\n          runtime === \"automatic\" &&\n          (name === \"__source\" || name === \"__self\")\n        ) {\n          if (found[name]) throw sourceSelfError(path, name);\n          found[name] = true;\n        }\n\n        accumulateAttribute(props, attr);\n      }\n\n      return props.length === 1 &&\n        t.isSpreadElement(props[0]) &&\n        // If an object expression is spread element's argument\n        // it is very likely to contain __proto__ and we should stop\n        // optimizing spread element\n        !t.isObjectExpression(props[0].argument)\n        ? props[0].argument\n        : props.length > 0\n        ? t.objectExpression(props)\n        : t.nullLiteral();\n    }\n  });\n\n  function getSource(source: string, importName: string) {\n    switch (importName) {\n      case \"Fragment\":\n        return `${source}/${development ? \"jsx-dev-runtime\" : \"jsx-runtime\"}`;\n      case \"jsxDEV\":\n        return `${source}/jsx-dev-runtime`;\n      case \"jsx\":\n      case \"jsxs\":\n        return `${source}/jsx-runtime`;\n      case \"createElement\":\n        return source;\n    }\n  }\n\n  function createImportLazily(\n    pass: PluginPass,\n    path: NodePath<Program>,\n    importName: string,\n    source: string,\n  ): () => Identifier | MemberExpression {\n    return () => {\n      const actualSource = getSource(source, importName);\n      if (isModule(path)) {\n        let reference = get(pass, `imports/${importName}`);\n        if (reference) return t.cloneNode(reference);\n\n        reference = addNamed(path, importName, actualSource, {\n          importedInterop: \"uncompiled\",\n          importPosition: \"after\",\n        });\n        set(pass, `imports/${importName}`, reference);\n\n        return reference;\n      } else {\n        let reference = get(pass, `requires/${actualSource}`);\n        if (reference) {\n          reference = t.cloneNode(reference);\n        } else {\n          reference = addNamespace(path, actualSource, {\n            importedInterop: \"uncompiled\",\n          });\n          set(pass, `requires/${actualSource}`, reference);\n        }\n\n        return t.memberExpression(reference, t.identifier(importName));\n      }\n    };\n  }\n}\n\nfunction toMemberExpression(id: string): Identifier | MemberExpression {\n  return (\n    id\n      .split(\".\")\n      .map(name => t.identifier(name))\n      // @ts-expect-error - The Array#reduce does not have a signature\n      // where the type of initialial value differs from callback return type\n      .reduce((object, property) => t.memberExpression(object, property))\n  );\n}\n\nfunction makeSource(path: NodePath, state: PluginPass) {\n  const location = path.node.loc;\n  if (!location) {\n    // the element was generated and doesn't have location information\n    return path.scope.buildUndefinedNode();\n  }\n\n  // @ts-expect-error todo: avoid mutating PluginPass\n  if (!state.fileNameIdentifier) {\n    const { filename = \"\" } = state;\n\n    const fileNameIdentifier = path.scope.generateUidIdentifier(\"_jsxFileName\");\n    const scope = path.hub.getScope();\n    if (scope) {\n      scope.push({\n        id: fileNameIdentifier,\n        init: t.stringLiteral(filename),\n      });\n    }\n    // @ts-expect-error todo: avoid mutating PluginPass\n    state.fileNameIdentifier = fileNameIdentifier;\n  }\n\n  return makeTrace(\n    t.cloneNode(\n      // @ts-expect-error todo: avoid mutating PluginPass\n      state.fileNameIdentifier,\n    ),\n    location.start.line,\n    location.start.column,\n  );\n}\n\nfunction makeTrace(\n  fileNameIdentifier: Identifier,\n  lineNumber?: number,\n  column0Based?: number,\n) {\n  const fileLineLiteral =\n    lineNumber != null ? t.numericLiteral(lineNumber) : t.nullLiteral();\n\n  const fileColumnLiteral =\n    column0Based != null ? t.numericLiteral(column0Based + 1) : t.nullLiteral();\n\n  const fileNameProperty = t.objectProperty(\n    t.identifier(\"fileName\"),\n    fileNameIdentifier,\n  );\n  const lineNumberProperty = t.objectProperty(\n    t.identifier(\"lineNumber\"),\n    fileLineLiteral,\n  );\n  const columnNumberProperty = t.objectProperty(\n    t.identifier(\"columnNumber\"),\n    fileColumnLiteral,\n  );\n  return t.objectExpression([\n    fileNameProperty,\n    lineNumberProperty,\n    columnNumberProperty,\n  ]);\n}\n\nfunction sourceSelfError(path: NodePath, name: string) {\n  const pluginName = `transform-react-jsx-${name.slice(2)}`;\n\n  return path.buildCodeFrameError(\n    `Duplicate ${name} prop found. You are most likely using the deprecated ${pluginName} Babel plugin. Both __source and __self are automatically set when using the automatic runtime. Please remove transform-react-jsx-source and transform-react-jsx-self from your Babel config.`,\n  );\n}\n"],"mappings":"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"}
=======
{"version":3,"names":["DEFAULT","importSource","runtime","pragma","pragmaFrag","JSX_SOURCE_ANNOTATION_REGEX","JSX_RUNTIME_ANNOTATION_REGEX","JSX_ANNOTATION_REGEX","JSX_FRAG_ANNOTATION_REGEX","get","pass","name","set","v","hasProto","node","properties","some","value","t","isObjectProperty","computed","shorthand","isIdentifier","key","isStringLiteral","createPlugin","development","declare","_","options","pure","PURE_ANNOTATION","throwIfNamespace","filter","RUNTIME_DEFAULT","IMPORT_SOURCE_DEFAULT","PRAGMA_DEFAULT","PRAGMA_FRAG_DEFAULT","useSpread","useBuiltIns","Error","injectMetaPropertiesVisitor","JSXOpeningElement","path","state","attributes","isThisAllowed","scope","push","jsxAttribute","jsxIdentifier","jsxExpressionContainer","thisExpression","makeSource","pushContainer","inherits","jsx","visitor","JSXNamespacedName","buildCodeFrameError","JSXSpreadChild","Program","enter","file","source","sourceSet","pragmaSet","pragmaFragSet","ast","comments","comment","sourceMatches","exec","runtimeMatches","jsxMatches","jsxFragMatches","createElement","toMemberExpression","fragment","cloneNode","define","id","createImportLazily","traverse","JSXFragment","exit","callExpr","buildCreateElementFragmentCall","buildJSXFragmentCall","replaceWith","JSXElement","shouldUseCreateElement","buildCreateElementCall","buildJSXElementCall","JSXAttribute","isJSXElement","isDerivedClass","classPath","superClass","isFunctionParent","isArrowFunctionExpression","isMethod","kind","parentPath","isTSModuleBlock","parent","call","args","callExpression","annotateAsPure","openingPath","seenPropsSpread","i","length","attr","isJSXAttribute","isJSXSpreadAttribute","convertJSXIdentifier","isJSXIdentifier","isReferenced","isValidIdentifier","type","stringLiteral","isJSXMemberExpression","memberExpression","object","property","isJSXNamespacedName","namespace","convertAttributeValue","isJSXExpressionContainer","expression","accumulateAttribute","array","attribute","arg","argument","isObjectExpression","spreadElement","booleanLiteral","replace","extra","raw","objectProperty","buildChildrenProperty","children","childrenNode","arrayExpression","undefined","identifier","getTag","attribsArray","extracted","Object","create","sourceSelfError","keyValue","react","buildChildren","attribs","buildJSXOpeningElementAttributes","objectExpression","buildUndefinedNode","__source","__self","props","reduce","nullLiteral","buildCreateElementOpeningElementAttributes","tagExpr","tagName","isCompatTag","objs","start","forEach","prop","isSpreadElement","slice","unshift","helper","addHelper","found","getSource","importName","actualSource","isModule","reference","addNamed","importedInterop","importPosition","addNamespace","split","map","location","loc","fileNameIdentifier","filename","generateUidIdentifier","getProgramParent","init","makeTrace","line","column","lineNumber","column0Based","fileLineLiteral","numericLiteral","fileColumnLiteral","template","pluginName"],"sources":["../src/create-plugin.ts"],"sourcesContent":["import jsx from \"@babel/plugin-syntax-jsx\";\nimport { declare } from \"@babel/helper-plugin-utils\";\nimport { template, types as t } from \"@babel/core\";\nimport type { PluginPass } from \"@babel/core\";\nimport type { NodePath, Scope, Visitor } from \"@babel/traverse\";\nimport { addNamed, addNamespace, isModule } from \"@babel/helper-module-imports\";\nimport annotateAsPure from \"@babel/helper-annotate-as-pure\";\nimport type {\n  CallExpression,\n  Class,\n  Expression,\n  Identifier,\n  JSXAttribute,\n  JSXElement,\n  JSXFragment,\n  JSXOpeningElement,\n  JSXSpreadAttribute,\n  MemberExpression,\n  ObjectExpression,\n  Program,\n} from \"@babel/types\";\n\nconst DEFAULT = {\n  importSource: \"react\",\n  runtime: \"automatic\",\n  pragma: \"React.createElement\",\n  pragmaFrag: \"React.Fragment\",\n};\n\nconst JSX_SOURCE_ANNOTATION_REGEX =\n  /^\\s*\\*?\\s*@jsxImportSource\\s+([^\\s]+)\\s*$/m;\nconst JSX_RUNTIME_ANNOTATION_REGEX = /^\\s*\\*?\\s*@jsxRuntime\\s+([^\\s]+)\\s*$/m;\n\nconst JSX_ANNOTATION_REGEX = /^\\s*\\*?\\s*@jsx\\s+([^\\s]+)\\s*$/m;\nconst JSX_FRAG_ANNOTATION_REGEX = /^\\s*\\*?\\s*@jsxFrag\\s+([^\\s]+)\\s*$/m;\n\nconst get = (pass: PluginPass, name: string) =>\n  pass.get(`@babel/plugin-react-jsx/${name}`);\nconst set = (pass: PluginPass, name: string, v: any) =>\n  pass.set(`@babel/plugin-react-jsx/${name}`, v);\n\nfunction hasProto(node: t.ObjectExpression) {\n  return node.properties.some(\n    value =>\n      t.isObjectProperty(value, { computed: false, shorthand: false }) &&\n      (t.isIdentifier(value.key, { name: \"__proto__\" }) ||\n        t.isStringLiteral(value.key, { value: \"__proto__\" })),\n  );\n}\n\nexport interface Options {\n  filter?: (node: t.Node, pass: PluginPass) => boolean;\n  importSource?: string;\n  pragma?: string;\n  pragmaFrag?: string;\n  pure?: string;\n  runtime?: \"automatic\" | \"classic\";\n  throwIfNamespace?: boolean;\n  useBuiltIns: boolean;\n  useSpread?: boolean;\n}\nexport default function createPlugin({\n  name,\n  development,\n}: {\n  name: string;\n  development: boolean;\n}) {\n  return declare((_, options: Options) => {\n    const {\n      pure: PURE_ANNOTATION,\n\n      throwIfNamespace = true,\n\n      // TODO (Babel 8): It should throw if this option is used with the automatic runtime\n      filter,\n\n      runtime: RUNTIME_DEFAULT = process.env.BABEL_8_BREAKING\n        ? \"automatic\"\n        : development\n        ? \"automatic\"\n        : \"classic\",\n\n      importSource: IMPORT_SOURCE_DEFAULT = DEFAULT.importSource,\n      pragma: PRAGMA_DEFAULT = DEFAULT.pragma,\n      pragmaFrag: PRAGMA_FRAG_DEFAULT = DEFAULT.pragmaFrag,\n    } = options;\n\n    if (process.env.BABEL_8_BREAKING) {\n      if (\"useSpread\" in options) {\n        throw new Error(\n          '@babel/plugin-transform-react-jsx: Since Babel 8, an inline object with spread elements is always used, and the \"useSpread\" option is no longer available. Please remove it from your config.',\n        );\n      }\n\n      if (\"useBuiltIns\" in options) {\n        const useBuiltInsFormatted = JSON.stringify(options.useBuiltIns);\n        throw new Error(\n          `@babel/plugin-transform-react-jsx: Since \"useBuiltIns\" is removed in Babel 8, you can remove it from the config.\n- Babel 8 now transforms JSX spread to object spread. If you need to transpile object spread with\n\\`useBuiltIns: ${useBuiltInsFormatted}\\`, you can use the following config\n{\n  \"plugins\": [\n    \"@babel/plugin-transform-react-jsx\"\n    [\"@babel/plugin-proposal-object-rest-spread\", { \"loose\": true, \"useBuiltIns\": ${useBuiltInsFormatted} }]\n  ]\n}`,\n        );\n      }\n    } else {\n      // eslint-disable-next-line no-var\n      var { useSpread = false, useBuiltIns = false } = options;\n\n      if (RUNTIME_DEFAULT === \"classic\") {\n        if (typeof useSpread !== \"boolean\") {\n          throw new Error(\n            \"transform-react-jsx currently only accepts a boolean option for \" +\n              \"useSpread (defaults to false)\",\n          );\n        }\n\n        if (typeof useBuiltIns !== \"boolean\") {\n          throw new Error(\n            \"transform-react-jsx currently only accepts a boolean option for \" +\n              \"useBuiltIns (defaults to false)\",\n          );\n        }\n\n        if (useSpread && useBuiltIns) {\n          throw new Error(\n            \"transform-react-jsx currently only accepts useBuiltIns or useSpread \" +\n              \"but not both\",\n          );\n        }\n      }\n    }\n\n    const injectMetaPropertiesVisitor: Visitor<PluginPass> = {\n      JSXOpeningElement(path, state) {\n        const attributes = [];\n        if (isThisAllowed(path.scope)) {\n          attributes.push(\n            t.jsxAttribute(\n              t.jsxIdentifier(\"__self\"),\n              t.jsxExpressionContainer(t.thisExpression()),\n            ),\n          );\n        }\n        attributes.push(\n          t.jsxAttribute(\n            t.jsxIdentifier(\"__source\"),\n            t.jsxExpressionContainer(makeSource(path, state)),\n          ),\n        );\n        path.pushContainer(\"attributes\", attributes);\n      },\n    };\n\n    return {\n      name,\n      inherits: jsx,\n      visitor: {\n        JSXNamespacedName(path) {\n          if (throwIfNamespace) {\n            throw path.buildCodeFrameError(\n              `Namespace tags are not supported by default. React's JSX doesn't support namespace tags. \\\nYou can set \\`throwIfNamespace: false\\` to bypass this warning.`,\n            );\n          }\n        },\n\n        JSXSpreadChild(path) {\n          throw path.buildCodeFrameError(\n            \"Spread children are not supported in React.\",\n          );\n        },\n\n        Program: {\n          enter(path, state) {\n            const { file } = state;\n            let runtime: string = RUNTIME_DEFAULT;\n\n            let source: string = IMPORT_SOURCE_DEFAULT;\n            let pragma: string = PRAGMA_DEFAULT;\n            let pragmaFrag: string = PRAGMA_FRAG_DEFAULT;\n\n            let sourceSet = !!options.importSource;\n            let pragmaSet = !!options.pragma;\n            let pragmaFragSet = !!options.pragmaFrag;\n\n            if (file.ast.comments) {\n              for (const comment of file.ast.comments) {\n                const sourceMatches = JSX_SOURCE_ANNOTATION_REGEX.exec(\n                  comment.value,\n                );\n                if (sourceMatches) {\n                  source = sourceMatches[1];\n                  sourceSet = true;\n                }\n\n                const runtimeMatches = JSX_RUNTIME_ANNOTATION_REGEX.exec(\n                  comment.value,\n                );\n                if (runtimeMatches) {\n                  runtime = runtimeMatches[1];\n                }\n\n                const jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);\n                if (jsxMatches) {\n                  pragma = jsxMatches[1];\n                  pragmaSet = true;\n                }\n                const jsxFragMatches = JSX_FRAG_ANNOTATION_REGEX.exec(\n                  comment.value,\n                );\n                if (jsxFragMatches) {\n                  pragmaFrag = jsxFragMatches[1];\n                  pragmaFragSet = true;\n                }\n              }\n            }\n\n            set(state, \"runtime\", runtime);\n            if (runtime === \"classic\") {\n              if (sourceSet) {\n                throw path.buildCodeFrameError(\n                  `importSource cannot be set when runtime is classic.`,\n                );\n              }\n\n              const createElement = toMemberExpression(pragma);\n              const fragment = toMemberExpression(pragmaFrag);\n\n              set(state, \"id/createElement\", () => t.cloneNode(createElement));\n              set(state, \"id/fragment\", () => t.cloneNode(fragment));\n\n              set(state, \"defaultPure\", pragma === DEFAULT.pragma);\n            } else if (runtime === \"automatic\") {\n              if (pragmaSet || pragmaFragSet) {\n                throw path.buildCodeFrameError(\n                  `pragma and pragmaFrag cannot be set when runtime is automatic.`,\n                );\n              }\n\n              const define = (name: string, id: string) =>\n                set(state, name, createImportLazily(state, path, id, source));\n\n              define(\"id/jsx\", development ? \"jsxDEV\" : \"jsx\");\n              define(\"id/jsxs\", development ? \"jsxDEV\" : \"jsxs\");\n              define(\"id/createElement\", \"createElement\");\n              define(\"id/fragment\", \"Fragment\");\n\n              set(state, \"defaultPure\", source === DEFAULT.importSource);\n            } else {\n              throw path.buildCodeFrameError(\n                `Runtime must be either \"classic\" or \"automatic\".`,\n              );\n            }\n\n            if (development) {\n              path.traverse(injectMetaPropertiesVisitor, state);\n            }\n          },\n\n          // TODO (Babel 8): Decide if this should be removed or brought back.\n          // see: https://github.com/babel/babel/pull/12253#discussion_r513086528\n          //\n          // exit(path, state) {\n          //   if (\n          //     get(state, \"runtime\") === \"classic\" &&\n          //     get(state, \"pragmaSet\") &&\n          //     get(state, \"usedFragment\") &&\n          //     !get(state, \"pragmaFragSet\")\n          //   ) {\n          //     throw new Error(\n          //       \"transform-react-jsx: pragma has been set but \" +\n          //         \"pragmaFrag has not been set\",\n          //     );\n          //   }\n          // },\n        },\n\n        JSXFragment: {\n          exit(path, file) {\n            let callExpr;\n            if (get(file, \"runtime\") === \"classic\") {\n              callExpr = buildCreateElementFragmentCall(path, file);\n            } else {\n              callExpr = buildJSXFragmentCall(path, file);\n            }\n\n            path.replaceWith(t.inherits(callExpr, path.node));\n          },\n        },\n\n        JSXElement: {\n          exit(path, file) {\n            let callExpr;\n            if (\n              get(file, \"runtime\") === \"classic\" ||\n              shouldUseCreateElement(path)\n            ) {\n              callExpr = buildCreateElementCall(path, file);\n            } else {\n              callExpr = buildJSXElementCall(path, file);\n            }\n\n            path.replaceWith(t.inherits(callExpr, path.node));\n          },\n        },\n\n        JSXAttribute(path) {\n          if (t.isJSXElement(path.node.value)) {\n            path.node.value = t.jsxExpressionContainer(path.node.value);\n          }\n        },\n      },\n    };\n\n    // Returns whether the class has specified a superclass.\n    function isDerivedClass(classPath: NodePath<Class>) {\n      return classPath.node.superClass !== null;\n    }\n\n    // Returns whether `this` is allowed at given scope.\n    function isThisAllowed(scope: Scope) {\n      // This specifically skips arrow functions as they do not rewrite `this`.\n      do {\n        const { path } = scope;\n        if (path.isFunctionParent() && !path.isArrowFunctionExpression()) {\n          if (!path.isMethod()) {\n            // If the closest parent is a regular function, `this` will be rebound, therefore it is fine to use `this`.\n            return true;\n          }\n          // Current node is within a method, so we need to check if the method is a constructor.\n          if (path.node.kind !== \"constructor\") {\n            // We are not in a constructor, therefore it is always fine to use `this`.\n            return true;\n          }\n          // Now we are in a constructor. If it is a derived class, we do not reference `this`.\n          return !isDerivedClass(path.parentPath.parentPath as NodePath<Class>);\n        }\n        if (path.isTSModuleBlock()) {\n          // If the closest parent is a TS Module block, `this` will not be allowed.\n          return false;\n        }\n      } while ((scope = scope.parent));\n      // We are not in a method or function. It is fine to use `this`.\n      return true;\n    }\n\n    function call(\n      pass: PluginPass,\n      name: string,\n      args: CallExpression[\"arguments\"],\n    ) {\n      const node = t.callExpression(get(pass, `id/${name}`)(), args);\n      if (PURE_ANNOTATION ?? get(pass, \"defaultPure\")) annotateAsPure(node);\n      return node;\n    }\n\n    // We want to use React.createElement, even in the case of\n    // jsx, for <div {...props} key={key} /> to distinguish it\n    // from <div key={key} {...props} />. This is an intermediary\n    // step while we deprecate key spread from props. Afterwards,\n    // we will stop using createElement in the transform.\n    function shouldUseCreateElement(path: NodePath<JSXElement>) {\n      const openingPath = path.get(\"openingElement\");\n      const attributes = openingPath.node.attributes;\n\n      let seenPropsSpread = false;\n      for (let i = 0; i < attributes.length; i++) {\n        const attr = attributes[i];\n        if (\n          seenPropsSpread &&\n          t.isJSXAttribute(attr) &&\n          attr.name.name === \"key\"\n        ) {\n          return true;\n        } else if (t.isJSXSpreadAttribute(attr)) {\n          seenPropsSpread = true;\n        }\n      }\n      return false;\n    }\n\n    function convertJSXIdentifier(\n      node: t.JSXIdentifier | t.JSXMemberExpression | t.JSXNamespacedName,\n      parent: t.JSXOpeningElement | t.JSXMemberExpression,\n    ): t.ThisExpression | t.StringLiteral | t.MemberExpression | t.Identifier {\n      if (t.isJSXIdentifier(node)) {\n        if (node.name === \"this\" && t.isReferenced(node, parent)) {\n          return t.thisExpression();\n        } else if (t.isValidIdentifier(node.name, false)) {\n          // @ts-expect-error cast AST type to Identifier\n          node.type = \"Identifier\";\n          return node as unknown as t.Identifier;\n        } else {\n          return t.stringLiteral(node.name);\n        }\n      } else if (t.isJSXMemberExpression(node)) {\n        return t.memberExpression(\n          convertJSXIdentifier(node.object, node),\n          convertJSXIdentifier(node.property, node),\n        );\n      } else if (t.isJSXNamespacedName(node)) {\n        /**\n         * If the flag \"throwIfNamespace\" is false\n         * print XMLNamespace like string literal\n         */\n        return t.stringLiteral(`${node.namespace.name}:${node.name.name}`);\n      }\n\n      // todo: this branch should be unreachable\n      return node;\n    }\n\n    function convertAttributeValue(\n      node: t.JSXAttribute[\"value\"] | t.BooleanLiteral,\n    ) {\n      if (t.isJSXExpressionContainer(node)) {\n        return node.expression;\n      } else {\n        return node;\n      }\n    }\n\n    function accumulateAttribute(\n      array: ObjectExpression[\"properties\"],\n      attribute: NodePath<JSXAttribute | JSXSpreadAttribute>,\n    ) {\n      if (t.isJSXSpreadAttribute(attribute.node)) {\n        const arg = attribute.node.argument;\n        // Collect properties into props array if spreading object expression\n        if (t.isObjectExpression(arg) && !hasProto(arg)) {\n          array.push(...arg.properties);\n        } else {\n          array.push(t.spreadElement(arg));\n        }\n        return array;\n      }\n\n      const value = convertAttributeValue(\n        attribute.node.name.name !== \"key\"\n          ? attribute.node.value || t.booleanLiteral(true)\n          : attribute.node.value,\n      );\n\n      if (attribute.node.name.name === \"key\" && value === null) {\n        throw attribute.buildCodeFrameError(\n          'Please provide an explicit key value. Using \"key\" as a shorthand for \"key={true}\" is not allowed.',\n        );\n      }\n\n      if (\n        t.isStringLiteral(value) &&\n        !t.isJSXExpressionContainer(attribute.node.value)\n      ) {\n        value.value = value.value.replace(/\\n\\s+/g, \" \");\n\n        // \"raw\" JSXText should not be used from a StringLiteral because it needs to be escaped.\n        delete value.extra?.raw;\n      }\n\n      if (t.isJSXNamespacedName(attribute.node.name)) {\n        // @ts-expect-error mutating AST\n        attribute.node.name = t.stringLiteral(\n          attribute.node.name.namespace.name +\n            \":\" +\n            attribute.node.name.name.name,\n        );\n      } else if (t.isValidIdentifier(attribute.node.name.name, false)) {\n        // @ts-expect-error mutating AST\n        attribute.node.name.type = \"Identifier\";\n      } else {\n        // @ts-expect-error mutating AST\n        attribute.node.name = t.stringLiteral(attribute.node.name.name);\n      }\n\n      array.push(\n        t.inherits(\n          t.objectProperty(\n            // @ts-expect-error The attribute.node.name is an Identifier now\n            attribute.node.name,\n            value,\n          ),\n          attribute.node,\n        ),\n      );\n      return array;\n    }\n\n    function buildChildrenProperty(children: Expression[]) {\n      let childrenNode;\n      if (children.length === 1) {\n        childrenNode = children[0];\n      } else if (children.length > 1) {\n        childrenNode = t.arrayExpression(children);\n      } else {\n        return undefined;\n      }\n\n      return t.objectProperty(t.identifier(\"children\"), childrenNode);\n    }\n\n    // Builds JSX into:\n    // Production: React.jsx(type, arguments, key)\n    // Development: React.jsxDEV(type, arguments, key, isStaticChildren, source, self)\n    function buildJSXElementCall(path: NodePath<JSXElement>, file: PluginPass) {\n      const openingPath = path.get(\"openingElement\");\n      const args: t.Expression[] = [getTag(openingPath)];\n\n      const attribsArray = [];\n      const extracted = Object.create(null);\n\n      // for React.jsx, key, __source (dev), and __self (dev) is passed in as\n      // a separate argument rather than in the args object. We go through the\n      // props and filter out these three keywords so we can pass them in\n      // as separate arguments later\n      for (const attr of openingPath.get(\"attributes\")) {\n        if (attr.isJSXAttribute() && t.isJSXIdentifier(attr.node.name)) {\n          const { name } = attr.node.name;\n          switch (name) {\n            case \"__source\":\n            case \"__self\":\n              if (extracted[name]) throw sourceSelfError(path, name);\n            /* falls through */\n            case \"key\": {\n              const keyValue = convertAttributeValue(attr.node.value);\n              if (keyValue === null) {\n                throw attr.buildCodeFrameError(\n                  'Please provide an explicit key value. Using \"key\" as a shorthand for \"key={true}\" is not allowed.',\n                );\n              }\n\n              extracted[name] = keyValue;\n              break;\n            }\n            default:\n              attribsArray.push(attr);\n          }\n        } else {\n          attribsArray.push(attr);\n        }\n      }\n\n      const children = t.react.buildChildren(path.node);\n\n      let attribs: t.ObjectExpression;\n\n      if (attribsArray.length || children.length) {\n        attribs = buildJSXOpeningElementAttributes(\n          attribsArray,\n          //@ts-expect-error The children here contains JSXSpreadChild,\n          // which will be thrown later\n          children,\n        );\n      } else {\n        // attributes should never be null\n        attribs = t.objectExpression([]);\n      }\n\n      args.push(attribs);\n\n      if (development) {\n        // isStaticChildren, __source, and __self are only used in development\n        // automatically include __source and __self in this plugin\n        // so we can eliminate the need for separate Babel plugins in Babel 8\n        args.push(\n          extracted.key ?? path.scope.buildUndefinedNode(),\n          t.booleanLiteral(children.length > 1),\n        );\n        if (extracted.__source) {\n          args.push(extracted.__source);\n          if (extracted.__self) args.push(extracted.__self);\n        } else if (extracted.__self) {\n          args.push(path.scope.buildUndefinedNode(), extracted.__self);\n        }\n      } else if (extracted.key !== undefined) {\n        args.push(extracted.key);\n      }\n\n      return call(file, children.length > 1 ? \"jsxs\" : \"jsx\", args);\n    }\n\n    // Builds props for React.jsx. This function adds children into the props\n    // and ensures that props is always an object\n    function buildJSXOpeningElementAttributes(\n      attribs: NodePath<JSXAttribute | JSXSpreadAttribute>[],\n      children: Expression[],\n    ) {\n      const props = attribs.reduce(accumulateAttribute, []);\n\n      // In React.jsx, children is no longer a separate argument, but passed in\n      // through the argument object\n      if (children?.length > 0) {\n        props.push(buildChildrenProperty(children));\n      }\n\n      return t.objectExpression(props);\n    }\n\n    // Builds JSX Fragment <></> into\n    // Production: React.jsx(type, arguments)\n    // Development: React.jsxDEV(type, { children })\n    function buildJSXFragmentCall(\n      path: NodePath<JSXFragment>,\n      file: PluginPass,\n    ) {\n      const args = [get(file, \"id/fragment\")()];\n\n      const children = t.react.buildChildren(path.node);\n\n      args.push(\n        t.objectExpression(\n          children.length > 0\n            ? [\n                buildChildrenProperty(\n                  //@ts-expect-error The children here contains JSXSpreadChild,\n                  // which will be thrown later\n                  children,\n                ),\n              ]\n            : [],\n        ),\n      );\n\n      if (development) {\n        args.push(\n          path.scope.buildUndefinedNode(),\n          t.booleanLiteral(children.length > 1),\n        );\n      }\n\n      return call(file, children.length > 1 ? \"jsxs\" : \"jsx\", args);\n    }\n\n    // Builds JSX Fragment <></> into\n    // React.createElement(React.Fragment, null, ...children)\n    function buildCreateElementFragmentCall(\n      path: NodePath<JSXFragment>,\n      file: PluginPass,\n    ) {\n      if (filter && !filter(path.node, file)) return;\n\n      return call(file, \"createElement\", [\n        get(file, \"id/fragment\")(),\n        t.nullLiteral(),\n        ...t.react.buildChildren(path.node),\n      ]);\n    }\n\n    // Builds JSX into:\n    // Production: React.createElement(type, arguments, children)\n    // Development: React.createElement(type, arguments, children, source, self)\n    function buildCreateElementCall(\n      path: NodePath<JSXElement>,\n      file: PluginPass,\n    ) {\n      const openingPath = path.get(\"openingElement\");\n\n      return call(file, \"createElement\", [\n        getTag(openingPath),\n        buildCreateElementOpeningElementAttributes(\n          file,\n          path,\n          openingPath.get(\"attributes\"),\n        ),\n        // @ts-expect-error JSXSpreadChild has been transformed in convertAttributeValue\n        ...t.react.buildChildren(path.node),\n      ]);\n    }\n\n    function getTag(openingPath: NodePath<JSXOpeningElement>) {\n      const tagExpr = convertJSXIdentifier(\n        openingPath.node.name,\n        openingPath.node,\n      );\n\n      let tagName: string;\n      if (t.isIdentifier(tagExpr)) {\n        tagName = tagExpr.name;\n      } else if (t.isStringLiteral(tagExpr)) {\n        tagName = tagExpr.value;\n      }\n\n      if (t.react.isCompatTag(tagName)) {\n        return t.stringLiteral(tagName);\n      } else {\n        return tagExpr;\n      }\n    }\n\n    /**\n     * The logic for this is quite terse. It's because we need to\n     * support spread elements. We loop over all attributes,\n     * breaking on spreads, we then push a new object containing\n     * all prior attributes to an array for later processing.\n     */\n    function buildCreateElementOpeningElementAttributes(\n      file: PluginPass,\n      path: NodePath<JSXElement>,\n      attribs: NodePath<JSXAttribute | JSXSpreadAttribute>[],\n    ) {\n      const runtime = get(file, \"runtime\");\n      if (!process.env.BABEL_8_BREAKING) {\n        if (runtime !== \"automatic\") {\n          const objs = [];\n          const props = attribs.reduce(accumulateAttribute, []);\n\n          if (!useSpread) {\n            // Convert syntax to use multiple objects instead of spread\n            let start = 0;\n            props.forEach((prop, i) => {\n              if (t.isSpreadElement(prop)) {\n                if (i > start) {\n                  objs.push(t.objectExpression(props.slice(start, i)));\n                }\n                objs.push(prop.argument);\n                start = i + 1;\n              }\n            });\n            if (props.length > start) {\n              objs.push(t.objectExpression(props.slice(start)));\n            }\n          } else if (props.length) {\n            objs.push(t.objectExpression(props));\n          }\n\n          if (!objs.length) {\n            return t.nullLiteral();\n          }\n\n          if (objs.length === 1) {\n            if (\n              !(\n                t.isSpreadElement(props[0]) &&\n                // If an object expression is spread element's argument\n                // it is very likely to contain __proto__ and we should stop\n                // optimizing spread element\n                t.isObjectExpression(props[0].argument)\n              )\n            ) {\n              return objs[0];\n            }\n          }\n\n          // looks like we have multiple objects\n          if (!t.isObjectExpression(objs[0])) {\n            objs.unshift(t.objectExpression([]));\n          }\n\n          const helper = useBuiltIns\n            ? t.memberExpression(t.identifier(\"Object\"), t.identifier(\"assign\"))\n            : file.addHelper(\"extends\");\n\n          // spread it\n          return t.callExpression(helper, objs);\n        }\n      }\n\n      const props: ObjectExpression[\"properties\"] = [];\n      const found = Object.create(null);\n\n      for (const attr of attribs) {\n        const name =\n          t.isJSXAttribute(attr) &&\n          t.isJSXIdentifier(attr.name) &&\n          attr.name.name;\n\n        if (\n          runtime === \"automatic\" &&\n          (name === \"__source\" || name === \"__self\")\n        ) {\n          if (found[name]) throw sourceSelfError(path, name);\n          found[name] = true;\n        }\n\n        accumulateAttribute(props, attr);\n      }\n\n      return props.length === 1 &&\n        t.isSpreadElement(props[0]) &&\n        // If an object expression is spread element's argument\n        // it is very likely to contain __proto__ and we should stop\n        // optimizing spread element\n        !t.isObjectExpression(props[0].argument)\n        ? props[0].argument\n        : props.length > 0\n        ? t.objectExpression(props)\n        : t.nullLiteral();\n    }\n  });\n\n  function getSource(source: string, importName: string) {\n    switch (importName) {\n      case \"Fragment\":\n        return `${source}/${development ? \"jsx-dev-runtime\" : \"jsx-runtime\"}`;\n      case \"jsxDEV\":\n        return `${source}/jsx-dev-runtime`;\n      case \"jsx\":\n      case \"jsxs\":\n        return `${source}/jsx-runtime`;\n      case \"createElement\":\n        return source;\n    }\n  }\n\n  function createImportLazily(\n    pass: PluginPass,\n    path: NodePath<Program>,\n    importName: string,\n    source: string,\n  ): () => Identifier | MemberExpression {\n    return () => {\n      const actualSource = getSource(source, importName);\n      if (isModule(path)) {\n        let reference = get(pass, `imports/${importName}`);\n        if (reference) return t.cloneNode(reference);\n\n        reference = addNamed(path, importName, actualSource, {\n          importedInterop: \"uncompiled\",\n          importPosition: \"after\",\n        });\n        set(pass, `imports/${importName}`, reference);\n\n        return reference;\n      } else {\n        let reference = get(pass, `requires/${actualSource}`);\n        if (reference) {\n          reference = t.cloneNode(reference);\n        } else {\n          reference = addNamespace(path, actualSource, {\n            importedInterop: \"uncompiled\",\n          });\n          set(pass, `requires/${actualSource}`, reference);\n        }\n\n        return t.memberExpression(reference, t.identifier(importName));\n      }\n    };\n  }\n}\n\nfunction toMemberExpression(id: string): Identifier | MemberExpression {\n  return (\n    id\n      .split(\".\")\n      .map(name => t.identifier(name))\n      // @ts-expect-error - The Array#reduce does not have a signature\n      // where the type of initial value differs from callback return type\n      .reduce((object, property) => t.memberExpression(object, property))\n  );\n}\n\nfunction makeSource(path: NodePath, state: PluginPass) {\n  const location = path.node.loc;\n  if (!location) {\n    // the element was generated and doesn't have location information\n    return path.scope.buildUndefinedNode();\n  }\n\n  // @ts-expect-error todo: avoid mutating PluginPass\n  if (!state.fileNameIdentifier) {\n    const { filename = \"\" } = state;\n\n    const fileNameIdentifier = path.scope.generateUidIdentifier(\"_jsxFileName\");\n    path.scope.getProgramParent().push({\n      id: fileNameIdentifier,\n      init: t.stringLiteral(filename),\n    });\n    // @ts-expect-error todo: avoid mutating PluginPass\n    state.fileNameIdentifier = fileNameIdentifier;\n  }\n\n  return makeTrace(\n    t.cloneNode(\n      // @ts-expect-error todo: avoid mutating PluginPass\n      state.fileNameIdentifier,\n    ),\n    location.start.line,\n    location.start.column,\n  );\n}\n\nfunction makeTrace(\n  fileNameIdentifier: Identifier,\n  lineNumber?: number,\n  column0Based?: number,\n) {\n  const fileLineLiteral =\n    lineNumber != null ? t.numericLiteral(lineNumber) : t.nullLiteral();\n\n  const fileColumnLiteral =\n    column0Based != null ? t.numericLiteral(column0Based + 1) : t.nullLiteral();\n\n  return template.expression.ast`{\n    fileName: ${fileNameIdentifier},\n    lineNumber: ${fileLineLiteral},\n    columnNumber: ${fileColumnLiteral},\n  }`;\n}\n\nfunction sourceSelfError(path: NodePath, name: string) {\n  const pluginName = `transform-react-jsx-${name.slice(2)}`;\n\n  return path.buildCodeFrameError(\n    `Duplicate ${name} prop found. You are most likely using the deprecated ${pluginName} Babel plugin. Both __source and __self are automatically set when using the automatic runtime. Please remove transform-react-jsx-source and transform-react-jsx-self from your Babel config.`,\n  );\n}\n"],"mappings":"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"}
>>>>>>> zen
>>>>>>> ede5c2d510e1c4029dfffa203387bb3f20d74fc6
