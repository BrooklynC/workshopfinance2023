"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = literalTemplate;
<<<<<<< HEAD
=======
<<<<<<< HEAD

>>>>>>> ede5c2d510e1c4029dfffa203387bb3f20d74fc6
var _options = require("./options");
var _parse = require("./parse");
var _populate = require("./populate");
<<<<<<< HEAD
=======

=======
var _options = require("./options");
var _parse = require("./parse");
var _populate = require("./populate");
>>>>>>> zen
>>>>>>> ede5c2d510e1c4029dfffa203387bb3f20d74fc6
function literalTemplate(formatter, tpl, opts) {
  const {
    metadata,
    names
  } = buildLiteralData(formatter, tpl, opts);
  return arg => {
    const defaultReplacements = {};
    arg.forEach((replacement, i) => {
      defaultReplacements[names[i]] = replacement;
    });
    return arg => {
      const replacements = (0, _options.normalizeReplacements)(arg);
<<<<<<< HEAD
=======
<<<<<<< HEAD

=======
>>>>>>> zen
>>>>>>> ede5c2d510e1c4029dfffa203387bb3f20d74fc6
      if (replacements) {
        Object.keys(replacements).forEach(key => {
          if (Object.prototype.hasOwnProperty.call(defaultReplacements, key)) {
            throw new Error("Unexpected replacement overlap.");
          }
        });
      }
<<<<<<< HEAD
=======
<<<<<<< HEAD

=======
>>>>>>> zen
>>>>>>> ede5c2d510e1c4029dfffa203387bb3f20d74fc6
      return formatter.unwrap((0, _populate.default)(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));
    };
  };
}
<<<<<<< HEAD
=======
<<<<<<< HEAD

=======
>>>>>>> zen
>>>>>>> ede5c2d510e1c4029dfffa203387bb3f20d74fc6
function buildLiteralData(formatter, tpl, opts) {
  let names;
  let nameSet;
  let metadata;
  let prefix = "";
<<<<<<< HEAD
=======
<<<<<<< HEAD

=======
>>>>>>> zen
>>>>>>> ede5c2d510e1c4029dfffa203387bb3f20d74fc6
  do {
    prefix += "$";
    const result = buildTemplateCode(tpl, prefix);
    names = result.names;
    nameSet = new Set(names);
    metadata = (0, _parse.default)(formatter, formatter.code(result.code), {
      parser: opts.parser,
      placeholderWhitelist: new Set(result.names.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])),
      placeholderPattern: opts.placeholderPattern,
      preserveComments: opts.preserveComments,
      syntacticPlaceholders: opts.syntacticPlaceholders
    });
  } while (metadata.placeholders.some(placeholder => placeholder.isDuplicate && nameSet.has(placeholder.name)));
<<<<<<< HEAD
=======
<<<<<<< HEAD

=======
>>>>>>> zen
>>>>>>> ede5c2d510e1c4029dfffa203387bb3f20d74fc6
  return {
    metadata,
    names
  };
}
<<<<<<< HEAD
function buildTemplateCode(tpl, prefix) {
  const names = [];
  let code = tpl[0];
=======
<<<<<<< HEAD

function buildTemplateCode(tpl, prefix) {
  const names = [];
  let code = tpl[0];

=======
function buildTemplateCode(tpl, prefix) {
  const names = [];
  let code = tpl[0];
>>>>>>> zen
>>>>>>> ede5c2d510e1c4029dfffa203387bb3f20d74fc6
  for (let i = 1; i < tpl.length; i++) {
    const value = `${prefix}${i - 1}`;
    names.push(value);
    code += value + tpl[i];
  }
<<<<<<< HEAD
=======
<<<<<<< HEAD

=======
>>>>>>> zen
>>>>>>> ede5c2d510e1c4029dfffa203387bb3f20d74fc6
  return {
    names,
    code
  };
<<<<<<< HEAD
}

//# sourceMappingURL=literal.js.map
=======
<<<<<<< HEAD
}
=======
}

//# sourceMappingURL=literal.js.map
>>>>>>> zen
>>>>>>> ede5c2d510e1c4029dfffa203387bb3f20d74fc6
